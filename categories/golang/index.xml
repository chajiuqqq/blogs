<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on 茶酒的小站</title><link>https://chajiuqqq.github.io/blogs/categories/golang/</link><description>Recent content in golang on 茶酒的小站</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 01 Mar 2023 13:50:07 +0800</lastBuildDate><atom:link href="https://chajiuqqq.github.io/blogs/categories/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Gokit项目结构和Consul结合实现服务注册和发现</title><link>https://chajiuqqq.github.io/blogs/p/gokit%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%92%8Cconsul%E7%BB%93%E5%90%88%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/</link><pubDate>Wed, 01 Mar 2023 13:50:07 +0800</pubDate><guid>https://chajiuqqq.github.io/blogs/p/gokit%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%92%8Cconsul%E7%BB%93%E5%90%88%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/</guid><description>&lt;h1 id="go-kit的三层结构">go-kit的三层结构&lt;/h1>
&lt;p>go-kit项目采用分层架构方式。&lt;/p>
&lt;ul>
&lt;li>transport层：处理http、grpc等逻辑。比如在http中就是返回一个http.Handler，里面包含了URL和对应处理器的关系&lt;/li>
&lt;li>endpoint层：用于接受请求，处理请求，返回响应。每个服务都会包装成一个endpoint，在endpoint中调用service的方法，最后返回组装好的response。类似Java中controller的写法，不过这里没有涉及URL路径，只是提供包装后的服务。&lt;/li>
&lt;li>service层：业务代码实现层，也就是定义了有什么服务，服务的具体实现。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/gokit%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%92%8Cconsul%E7%BB%93%E5%90%88%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/1.png"
width="1598"
height="394"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/gokit%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%92%8Cconsul%E7%BB%93%E5%90%88%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/1_hu7f74198fd50c76ee75e9c81f8c66bfea_337892_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/gokit%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%92%8Cconsul%E7%BB%93%E5%90%88%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/1_hu7f74198fd50c76ee75e9c81f8c66bfea_337892_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="405"
data-flex-basis="973px"
>&lt;/p>
&lt;p>代码中使用了go-kit的函数，影响较大的是endpoint层和transport层。写法和我们普通分层写不太一样，用了很多go-kit的API。下面我们先从service层讲起。&lt;/p>
&lt;h2 id="service层">service层&lt;/h2>
&lt;p>作为服务端，如果想要使用服务注册和发现中心，比如consul，那么服务端需要有这三个功能，&lt;strong>我们抽象为一个接口：&lt;/strong>&lt;/p>
&lt;pre>&lt;code>type DiscoveryClient interface {
/**
* 服务注册接口
* @param serviceName 服务名
* @param instanceId 服务实例Id
* @param instancePort 服务实例端口
* @param healthCheckUrl 健康检查地址
* @param instanceHost 服务实例地址
* @param meta 服务实例元数据
*/
Register(serviceName, instanceId, healthCheckUrl string, instanceHost string, instancePort int, meta map[string]string, logger *log.Logger) bool
/**
* 服务注销接口
* @param instanceId 服务实例Id
*/
DeRegister(instanceId string, logger *log.Logger) bool
/**
* 发现服务实例接口
* @param serviceName 服务名
*/
DiscoverServices(serviceName string, logger *log.Logger) []interface{}
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Register用于把自己注册到consul&lt;/li>
&lt;li>DeRegister用于向consul注销自己的服务&lt;/li>
&lt;li>DiscoverServices用于向consul请求别的服务&lt;/li>
&lt;/ul>
&lt;p>对应可以有自己的接口实现，比如定义MyDiscoverClient结构，然后实现DiscoveryClient接口，如注册方法可以自己写http请求，发送到consul注册；或者定义KitDiscoverClient结构，然后实现DiscoveryClient接口，调用go-kit的consul client进行快速注册。&lt;/p>
&lt;p>简单贴一个注册方法的go-kit实现：&lt;/p>
&lt;pre>&lt;code>func (consulClient *KitDiscoverClient) Register(serviceName, instanceId, healthCheckUrl string, instanceHost string, instancePort int, meta map[string]string, logger *log.Logger) bool {
// 1. 构建服务实例元数据
serviceRegistration := &amp;amp;api.AgentServiceRegistration{
ID: instanceId,
Name: serviceName,
Address: instanceHost,
Port: instancePort,
Meta: meta,
Check: &amp;amp;api.AgentServiceCheck{
DeregisterCriticalServiceAfter: &amp;quot;30s&amp;quot;,
HTTP: &amp;quot;http://&amp;quot; + instanceHost + &amp;quot;:&amp;quot; + strconv.Itoa(instancePort) + healthCheckUrl,
Interval: &amp;quot;15s&amp;quot;,
},
}
// 2. 发送服务注册到 Consul 中
err := consulClient.client.Register(serviceRegistration)
if err != nil {
log.Println(&amp;quot;Register Service Error!&amp;quot;)
return false
}
log.Println(&amp;quot;Register Service Success!&amp;quot;)
return true
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>第二个接口是Service接口&lt;/strong>，包含你可以提供什么服务，比如连接字符串，比如心跳检查，比如发现服务。如：&lt;/p>
&lt;pre>&lt;code>type Service interface {
// HealthCheck check service health status
HealthCheck() bool
// sayHelloService
SayHello() string
// discovery service from consul by serviceName
DiscoveryService(ctx context.Context, serviceName string) ([]interface{}, error)
}
&lt;/code>&lt;/pre>
&lt;p>然后提供自己的结构实现，如DiscoveryServiceImpl，这个结构里也可以包含上面提到的DiscoveryClient实例，这样就可以复用DiscoveryClient的实现了：&lt;/p>
&lt;pre>&lt;code>//定义接口实现的结构
type DiscoveryServiceImpl struct {
discoveryClient discover.DiscoveryClient
}
//定义工厂方法，其实不要也可以
func NewDiscoveryServiceImpl(discoveryClient discover.DiscoveryClient) Service {
return &amp;amp;DiscoveryServiceImpl{
discoveryClient:discoveryClient,
}
}
//下面是实现接口的方法
func (*DiscoveryServiceImpl) SayHello() string {
return &amp;quot;Hello World!&amp;quot;
}
func (service *DiscoveryServiceImpl) DiscoveryService(ctx context.Context, serviceName string) ([]interface{}, error) {
instances := service.discoveryClient.DiscoverServices(serviceName, config.Logger)
if instances == nil || len(instances) == 0 {
return nil, ErrNotServiceInstances
}
return instances, nil
}
// HealthCheck implement Service method
// 用于检查服务的健康状态，这里仅仅返回true
func (*DiscoveryServiceImpl) HealthCheck() bool {
return true
}
&lt;/code>&lt;/pre>
&lt;p>通过上面的工厂方法NewDiscoveryServiceImpl，可以构建出一个Service的实现，用于调用自己的各种service&lt;/p>
&lt;pre>&lt;code>// 声明并初始化 Service
var svc = service.NewDiscoveryServiceImpl(discoveryClient)
&lt;/code>&lt;/pre>
&lt;p>接下来是要把服务暴露出来，一个很简单的方法是通过URL暴露，比如将GET的/say-hello映射到Service的sayHello方法上，也就是HTTP服务器里用处理器去处理URL请求。但是go-kit使用了endpoint的概念，把服务称为endpoint，其中不包含对应的URL。&lt;/p>
&lt;p>URL和endpoint的绑定我们放在了transport层实现。&lt;/p>
&lt;h2 id="endpoint层">endpoint层&lt;/h2>
&lt;p>首先介绍endpoint层。每个服务都是一个endpoint，所以构建一个机构，包含所有的服务（endpoint）：&lt;/p>
&lt;pre>&lt;code>type DiscoveryEndpoints struct {
SayHelloEndpoint endpoint.Endpoint
DiscoveryEndpoint endpoint.Endpoint
HealthCheckEndpoint endpoint.Endpoint
}
&lt;/code>&lt;/pre>
&lt;p>上面的endpoint.Endpoint其实就是一个函数别名：&lt;/p>
&lt;pre>&lt;code>func(ctx context.Context, request interface{}) (response interface{}, err error)
&lt;/code>&lt;/pre>
&lt;p>也就是说，DiscoveryEndpoints是包含了几个函数的结构，这几个函数也就是提供请求响应服务的。&lt;/p>
&lt;p>然后需要定义每个服务的请求结构、响应结构，如：&lt;/p>
&lt;blockquote>
&lt;p>SayHelloEndpoint&amp;ndash;&amp;gt;SayHelloRequest、SayHelloResponse&lt;/p>
&lt;p>DiscoveryEndpoint&amp;ndash;&amp;gt;DiscoveryRequest、DiscoveryResponse&lt;/p>
&lt;/blockquote>
&lt;p>每个结构里就是你需要传递的数据字段，没有的话就空，同时要指明json序列化tag：&lt;/p>
&lt;pre>&lt;code>// 打招呼请求结构体
type SayHelloRequest struct {
}
// 打招呼响应结构体
type SayHelloResponse struct {
Message string `json:&amp;quot;message&amp;quot;`
}
&lt;/code>&lt;/pre>
&lt;p>然后是写函数返回这个具体的endpoint，可以看到就是返回一个函数，最后返回的是SayHelloResponse：&lt;/p>
&lt;pre>&lt;code>// 创建打招呼 Endpoint
func MakeSayHelloEndpoint(svc service.Service) endpoint.Endpoint {
return func(ctx context.Context, request interface{}) (response interface{}, err error) {
message := svc.SayHello()
return SayHelloResponse{
Message:message,
}, nil
}
}
&lt;/code>&lt;/pre>
&lt;p>如果有请求数据，如何从请求中获取？&lt;/p>
&lt;p>可以从request对象中转成你这个endpoint对应的请求结构，如&lt;code>req := request.(DiscoveryRequest)&lt;/code>，这样就可以用结构里的数据了。&lt;/p>
&lt;pre>&lt;code>// 创建服务发现的 Endpoint
func MakeDiscoveryEndpoint(svc service.Service) endpoint.Endpoint {
return func(ctx context.Context, request interface{}) (response interface{}, err error) {
req := request.(DiscoveryRequest)
instances, err := svc.DiscoveryService(ctx, req.ServiceName)
var errString = &amp;quot;&amp;quot;
if err != nil{
errString = err.Error()
}
return &amp;amp;DiscoveryResponse{
Instances:instances,
Error:errString,
}, nil
}
}
&lt;/code>&lt;/pre>
&lt;p>你可能会有疑问，为什么request直接可以转成对应的请求结构，是如何转的呢？这在后面会提到，系统会使用我们提供的反序列化方法，将请求decode为我们设计的请求结构。同理，最后response结构如何序列化发送给客户端？也是调用了我们提供的序列化方法。&lt;/p>
&lt;p>至此，endpoint构建完毕&lt;/p>
&lt;h2 id="transport层">transport层&lt;/h2>
&lt;p>如在http服务中，我们可以构建一个函数返回Handler。区别于直接提供给URL一个处理器或处理器函数，这边我们使用kithttp提供的处理器。&lt;/p>
&lt;p>我们需要提供几个参数去构建这个处理器：&lt;/p>
&lt;ul>
&lt;li>endpoint：服务处理函数，如endpoints.SayHelloEndpoint&lt;/li>
&lt;li>请求解码函数：如decodeSayHelloRequest&lt;/li>
&lt;li>响应编码函数：如encodeJsonResponse&lt;/li>
&lt;li>处理器选项&lt;/li>
&lt;/ul>
&lt;p>看看第一个服务是如何暴露的：&lt;/p>
&lt;ul>
&lt;li>映射GET的/say-hello到一个处理器&lt;/li>
&lt;li>这个处理器包含endpoints.SayHelloEndpoint用于处理请求，并返回响应&lt;/li>
&lt;li>包含decodeSayHelloRequest用于将请求解码到SayHelloRequest&lt;/li>
&lt;li>包含encodeJsonResponse用于将SayHelloRequest转为JSON格式&lt;/li>
&lt;li>最后包含几个错误处理的方式&lt;/li>
&lt;/ul>
&lt;p>see：&lt;/p>
&lt;pre>&lt;code>// MakeHttpHandler make http handler use mux
func MakeHttpHandler(ctx context.Context, endpoints endpts.DiscoveryEndpoints, logger log.Logger) http.Handler {
r := mux.NewRouter()
options := []kithttp.ServerOption{
kithttp.ServerErrorHandler(transport.NewLogErrorHandler(logger)),
kithttp.ServerErrorEncoder(encodeError),
}
r.Methods(&amp;quot;GET&amp;quot;).Path(&amp;quot;/say-hello&amp;quot;).Handler(kithttp.NewServer(
endpoints.SayHelloEndpoint,
decodeSayHelloRequest,
encodeJsonResponse,
options...,
))
r.Methods(&amp;quot;GET&amp;quot;).Path(&amp;quot;/discovery&amp;quot;).Handler(kithttp.NewServer(
endpoints.DiscoveryEndpoint,
decodeDiscoveryRequest,
encodeJsonResponse,
options...,
))
// create health check handler
r.Methods(&amp;quot;GET&amp;quot;).Path(&amp;quot;/health&amp;quot;).Handler(kithttp.NewServer(
endpoints.HealthCheckEndpoint,
decodeHealthCheckRequest,
encodeJsonResponse,
options...,
))
return r
}
&lt;/code>&lt;/pre>
&lt;p>当然上面提到的请求解码函数和响应编码函数都是自己写的，函数签名要遵照不同格式哦：&lt;/p>
&lt;pre>&lt;code>// decodeSayHelloRequest decode request params to struct
func decodeSayHelloRequest(_ context.Context, r *http.Request) (interface{}, error) {
return endpts.SayHelloRequest{}, nil
}
// decodeDiscoveryRequest decode request params to struct
func decodeDiscoveryRequest(_ context.Context, r *http.Request) (interface{}, error) {
serviceName := r.URL.Query().Get(&amp;quot;serviceName&amp;quot;)
if serviceName == &amp;quot;&amp;quot;{
return nil, ErrorBadRequest
}
return endpts.DiscoveryRequest{
ServiceName:serviceName,
}, nil
}
// decodeHealthCheckRequest decode request
func decodeHealthCheckRequest(ctx context.Context, r *http.Request) (interface{}, error) {
return endpts.HealthRequest{}, nil
}
// encodeJsonResponse encode response to return
func encodeJsonResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {
w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json;charset=utf-8&amp;quot;)
return json.NewEncoder(w).Encode(response)
}
&lt;/code>&lt;/pre>
&lt;h1 id="main函数调用">main函数调用&lt;/h1>
&lt;p>处理流程如下&lt;/p>
&lt;ol>
&lt;li>读取consulHost, consulPort&lt;/li>
&lt;li>用上述参数构建discoveryClient&lt;/li>
&lt;li>用discoveryClient构建service&lt;/li>
&lt;li>用service构建若干个endpoints&lt;/li>
&lt;li>用若干个endpoints构建transport的handler&lt;/li>
&lt;li>向consul注册自己&lt;/li>
&lt;li>用handler和端口构建并开启http服务&lt;/li>
&lt;li>监听到终止信号则向consul取消注册，并退出服务&lt;/li>
&lt;/ol>
&lt;p>注册时候有个问题，向服务中心注册时只要提交instanceId、serviceName、instanceHost、instancePort等信息，但是不包含结构化的有什么服务，服务对应的URL是什么，别人通过服务名查询到该实例，知道该实例的host和port，但是接下来怎做？我还是不知道你提供什么服务啊，不知道服务在哪个URL。&lt;/p>
&lt;p>然后调用别人的服务也是手动发送http请求吗。&lt;/p>
&lt;p>学了grpc之后，明白rpc是解决微服务之间的调用问题，而服务的注册和发现是这一章解决的，如何将二者结合？比如某个rpc服务向服务中心注册，然后客户端查询“XXX”服务，获得“XXX”服务的地址和端口，然后建立rpc连接，用rpc去调用。这是一个比较合理的逻辑。&lt;/p>
&lt;p>即服务中心解决服务在哪的问题，RPC解决服务调用、返回的问题&lt;/p></description></item><item><title>介绍一下grpc的使用</title><link>https://chajiuqqq.github.io/blogs/p/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bgrpc%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Tue, 28 Feb 2023 11:28:33 +0800</pubDate><guid>https://chajiuqqq.github.io/blogs/p/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bgrpc%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>&lt;p>gRPC和protocol buffers通常被一起使用，protoBuf是gRPC的接口定义语言，也是其底层消息交换结构。通过gRPC，一个客户端可以像调用本地方法一样调用服务端应用的方法。客户端和服务端可以在多种不同环境下互动，比如java作为服务端语言，而go、python等作为客户端语言。&lt;/p>
&lt;p>gRPC使用protoBuf作为结构化数据的序列算法，可以在&lt;code>.proto&lt;/code>文件中定义数据结构，并用&lt;code>protoc&lt;/code>生成目标语言的客户端、服务端代码。&lt;/p>
&lt;p>下面是一个例子，数据被定义为一个message，并包含一系列的域；用rpc和方法名，参数，返回值构成服务。&lt;/p>
&lt;pre>&lt;code>// The greeter service definition.
service Greeter {
// Sends a greeting
rpc SayHello (HelloRequest) returns (HelloReply) {}
}
// The request message containing the user's name.
message HelloRequest {
string name = 1;
}
// The response message containing the greetings
message HelloReply {
string message = 1;
}
&lt;/code>&lt;/pre>
&lt;p>在生成客户端、服务端代码后，还需要进一步开发使用。&lt;/p>
&lt;h1 id="string-service例子">string-service例子&lt;/h1>
&lt;p>下面以一个string-service作为例子介绍，首先定义proto文件：&lt;/p>
&lt;pre>&lt;code>syntax = &amp;quot;proto3&amp;quot;;
package pb;
option go_package = &amp;quot;grpc-string-test/pb&amp;quot;;
service StringService{
rpc Concat(StringRequest) returns (StringResponse){}
rpc Diff(StringRequest) returns (StringResponse){}
}
message StringRequest{
string A = 1;
string B = 2;
}
message StringResponse{
string Ret = 1;
string err = 2;
}
&lt;/code>&lt;/pre>
&lt;p>proto3需要加上&lt;code>option go_package = &amp;quot;grpc-string-test/pb&amp;quot;;&lt;/code>前面是model名，后面是包名。这样才能生成成功。&lt;/p>
&lt;p>编译代码是：&lt;/p>
&lt;pre>&lt;code>protoc --go_out=. --go_opt=paths=source_relative \
--go-grpc_out=. --go-grpc_opt=paths=source_relative \
string.proto
&lt;/code>&lt;/pre>
&lt;p>这个命令需要到proto文件的目录执行。最后string.proto是要转换的proto文件名。最后会在当前目录下生成两个文件&lt;code>string.pb.go&lt;/code>和&lt;code>string_grpc.pb.go&lt;/code>，客户端和服务端都需要用到这两个文件。&lt;/p>
&lt;h2 id="server端">server端&lt;/h2>
&lt;p>为了实现具体的Concat和Diff方法，需要建立一个结构，并实现StringServiceServer接口&lt;/p>
&lt;p>你首先可以这么做：&lt;/p>
&lt;pre>&lt;code>type StringService struct {
pb.UnimplementedStringServiceServer
}
&lt;/code>&lt;/pre>
&lt;p>嵌入UnimplementedStringServiceServer，这是自动生成的一个结构，这样就默认实现了StringServiceServer接口，然后再重写Concat和Diff方法：&lt;/p>
&lt;pre>&lt;code>func (s *StringService) Concat(ctx context.Context, req *StringRequest) (*StringResponse, error) {
log.Println(req)
if len(req.A)+len(req.B) &amp;gt; StrMaxSize {
response := StringResponse{Ret: &amp;quot;&amp;quot;}
return &amp;amp;response, nil
}
response := StringResponse{Ret: req.A + req.B}
return &amp;amp;response, nil
}
func (s *StringService) Diff(ctx context.Context, req *StringRequest) (*StringResponse, error) {
log.Println(req)
if len(req.A) &amp;lt; 1 || len(req.B) &amp;lt; 1 {
response := StringResponse{Ret: &amp;quot;&amp;quot;}
return &amp;amp;response, nil
}
res := &amp;quot;&amp;quot;
if len(req.A) &amp;gt;= len(req.B) {
for _, char := range req.B {
if strings.Contains(req.A, string(char)) {
res = res + string(char)
}
}
} else {
for _, char := range req.A {
if strings.Contains(req.B, string(char)) {
res = res + string(char)
}
}
}
response := StringResponse{Ret: res}
return &amp;amp;response, nil
}
&lt;/code>&lt;/pre>
&lt;p>注意到传入参数是StringRequest，返回StringResponse，也就是我们之前定义的消息结构。&lt;/p>
&lt;p>写好了业务到底如何实现，下面要开启server对端口的监听，接受rpc请求，流程如下：&lt;/p>
&lt;ul>
&lt;li>获取某端口的Listener&lt;/li>
&lt;li>新建grpc.Server和上面我们定义的StringService&lt;/li>
&lt;li>调用RegisterStringServiceServer向grpc.Server注册StringService&lt;/li>
&lt;li>开启rpc监听&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> func main() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lis, err := net.Listen(&amp;#34;tcp&amp;#34;, &amp;#34;127.0.0.1:1234&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if err != nil {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> log.Fatalf(&amp;#34;failed to listen: %v&amp;#34;, err)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> log.Println(&amp;#34;server at 127.0.0.1:1234&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> grpcServer := grpc.NewServer()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> stringService := new(service.StringService)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> pb.RegisterStringServiceServer(grpcServer, stringService)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> grpcServer.Serve(lis)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="client端">client端&lt;/h2>
&lt;p>client只要建立rpc连接，然后调用服务即可。流程如下：&lt;/p>
&lt;ul>
&lt;li>grpc.Dial拨号建立rpc连接，获得conn&lt;/li>
&lt;li>从conn获取stringClient，这个变量实现的接口包含所有提供的服务&lt;/li>
&lt;li>由stringClient调用各种服务&lt;/li>
&lt;/ul>
&lt;p>注意传入参数是我们之前定义的StringRequest，返回StringResponse，非常完美&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> func main() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> serviceAddress := &amp;#34;127.0.0.1:1234&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> conn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if err != nil {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> panic(&amp;#34;connect error&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> defer conn.Close()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> stringClient := pb.NewStringServiceClient(conn)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> stringReq := &amp;amp;pb.StringRequest{A: &amp;#34;A&amp;#34;, B: &amp;#34;B&amp;#34;}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> reply, _ := stringClient.Concat(context.Background(), stringReq)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> fmt.Printf(&amp;#34;StringService Concat : %s concat %s = %s\n&amp;#34;, stringReq.A, stringReq.B, reply.Ret)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>至此，server和client都写完了，开启server，然后开启client，就可以进行rpc调用。&lt;/p>
&lt;h1 id="使用流的string-service例子">使用流的string-service例子&lt;/h1>
&lt;p>流指的是请求消息流或响应消息流，每个单位都是对应的请求结构或响应结构，并持续发送，好处是可以连续发送，连续处理。而不是发一个返回一个，发一个返回一个。&lt;/p>
&lt;p>grpc支持单向流或双向流。在proto文件中给参数添加&lt;code>stream&lt;/code>关键字就可以指明这是以流的形式发送的参数（或结果）：&lt;/p>
&lt;pre>&lt;code>service StringService{
rpc Concat(StringRequest) returns (StringResponse){}
rpc Diff(StringRequest) returns (StringResponse){}
rpc ConcatServerStream(StringRequest) returns (stream StringResponse){}
rpc ConcatClientStream(stream StringRequest) returns (StringResponse){}
rpc ConcatDoubleStream(stream StringRequest) returns (stream StringResponse){}
}
&lt;/code>&lt;/pre>
&lt;h2 id="server发流">server发流&lt;/h2>
&lt;p>这指的是，客户端发一个req，服务端流返回res，客户端读取res流。我们要关注的就是client调用服务，接受流请求的过程；和服务端发送流的写法。&lt;/p>
&lt;pre>&lt;code>//client
func streamServerConn(stringClient pb.StringServiceClient) {
stringReq := &amp;amp;pb.StringRequest{A: &amp;quot;A&amp;quot;, B: &amp;quot;B&amp;quot;}
//接受流
stream, _ := stringClient.ConcatServerStream(context.Background(), stringReq)
//循环读取流
for {
item, err := stream.Recv()
if err == io.EOF {
break
}
if err != nil {
log.Println(&amp;quot;fail to recv:&amp;quot;, err)
}
fmt.Printf(&amp;quot;StringService Concat : %s concat %s = %s\n&amp;quot;, stringReq.A, stringReq.B, item.Ret)
}
}
//server
func (s *StringService) ConcatServerStream(req *StringRequest, qs StringService_ConcatServerStreamServer) error {
response := StringResponse{Ret: req.A + req.B}
for i := 0; i &amp;lt; 10; i++ {
qs.Send(&amp;amp;response)
}
return nil
}
&lt;/code>&lt;/pre>
&lt;h2 id="client发流">client发流&lt;/h2>
&lt;pre>&lt;code>//client
func streamClientConn(stringClient pb.StringServiceClient) {
stream, err := stringClient.ConcatClientStream(context.Background())
//流式发送requset
for i := 0; i &amp;lt; 10; i++ {
if err != nil {
log.Println(&amp;quot;fail to call:&amp;quot;, err)
break
}
stream.Send(&amp;amp;pb.StringRequest{A: strconv.Itoa(i), B: strconv.Itoa(i + 1)})
}
//发完后读取一个response
recv, err := stream.CloseAndRecv()
if err != nil {
log.Println(&amp;quot;fail to recv:&amp;quot;, err)
}
fmt.Printf(&amp;quot;Ret is %s\n&amp;quot;, recv.Ret)
}
//server
func (s *StringService) ConcatClientStream(qs StringService_ConcatClientStreamServer) error {
var params []string
for {
item, err := qs.Recv()
//客户端发完了，服务器才处理并返回一个response
if err == io.EOF {
qs.SendAndClose(&amp;amp;StringResponse{Ret: strings.Join(params, &amp;quot;&amp;quot;)})
return nil
}
if err != nil {
log.Println(&amp;quot;fail to recv:&amp;quot;, err)
return err
}
params = append(params, item.A, item.B)
}
}
&lt;/code>&lt;/pre>
&lt;h2 id="双向流">双向流&lt;/h2>
&lt;pre>&lt;code>//client
func doubleStreamConn(stringClient pb.StringServiceClient) {
stream, _ := stringClient.ConcatDoubleStream(context.Background())
var i int
for {
err := stream.Send(&amp;amp;pb.StringRequest{A: strconv.Itoa(i), B: strconv.Itoa(i + 1)})
if err != nil {
log.Println(&amp;quot;fail to send:&amp;quot;, err)
break
}
recv, err := stream.Recv()
if err != nil {
log.Println(&amp;quot;fail to recv:&amp;quot;, err)
break
}
fmt.Printf(&amp;quot;Ret is %s\n&amp;quot;, recv.Ret)
i++
time.Sleep(time.Second)
}
}
//server
func (s *StringService) ConcatDoubleStream(qs StringService_ConcatDoubleStreamServer) error {
for {
in, err := qs.Recv()
if err == io.EOF {
return nil
}
if err != nil {
log.Println(&amp;quot;fail to recv:&amp;quot;, err)
return err
}
qs.Send(&amp;amp;StringResponse{Ret: in.A + in.B})
}
}
&lt;/code>&lt;/pre>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>流传输：&lt;/p>
&lt;ul>
&lt;li>发送一个message：stream.send()&lt;/li>
&lt;li>接受一个message：stream.recv()&lt;/li>
&lt;li>发送一个msg，并关闭：stream.SendAndClose()&lt;/li>
&lt;li>接受一个msg，并关闭：stream.CloseAndRecv()&lt;/li>
&lt;li>判断流是否结束：err == io.EOF&lt;/li>
&lt;/ul></description></item><item><title>一个使用Go Rpc库实现的RPC例子</title><link>https://chajiuqqq.github.io/blogs/p/%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8go-rpc%E5%BA%93%E5%AE%9E%E7%8E%B0%E7%9A%84rpc%E4%BE%8B%E5%AD%90/</link><pubDate>Sat, 25 Feb 2023 13:14:03 +0800</pubDate><guid>https://chajiuqqq.github.io/blogs/p/%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8go-rpc%E5%BA%93%E5%AE%9E%E7%8E%B0%E7%9A%84rpc%E4%BE%8B%E5%AD%90/</guid><description>&lt;p>本文使用go rpc库实现服务的创建、客户端的请求。&lt;/p>
&lt;p>server提供字符串拼接和字符串区别的服务，运行在127.0.0.1:1234。client可以调用rpc发送请求，调用server上的服务，并获取到结果。&lt;/p>
&lt;p>&lt;strong>注意点：&lt;/strong>&lt;/p>
&lt;p>client和server都要维护请求参数结构和响应参数结构，如拼接字符串的请求参数：&lt;/p>
&lt;pre>&lt;code>type StringRequest struct {
A string
B string
}
&lt;/code>&lt;/pre>
&lt;p>响应结构这里用string即可，所以没有专门定义结构。&lt;/p>
&lt;p>client调用Call或Go方法，传入远程方法名（结构+方法，如&lt;code>StringService.Concat&lt;/code>）、请求结构、响应结构的指针，等待结果完成即可。&lt;/p>
&lt;p>&lt;strong>结果：&lt;/strong>&lt;/p>
&lt;p>server运行：&lt;/p>
&lt;pre>&lt;code>go build &amp;amp;&amp;amp; ./rpc-server
2023/02/25 13:11:20 server at 127.0.0.1:1234
&lt;/code>&lt;/pre>
&lt;p>运行client：&lt;/p>
&lt;pre>&lt;code>go build &amp;amp;&amp;amp; ./rpc-client
StringService Concat : A concat B = AB
StringService Diff : ABC diff BCD = BC
&lt;/code>&lt;/pre>
&lt;h2 id="server">server&lt;/h2>
&lt;p>StringService是实现了Service接口的结构。&lt;/p>
&lt;h3 id="servergo">server.go&lt;/h3>
&lt;pre>&lt;code>package service
import (
&amp;quot;errors&amp;quot;
&amp;quot;strings&amp;quot;
)
type StringRequest struct{
A string
B string
}
type Service interface {
Concat(req StringRequest, ret *string) error
Diff(req StringRequest, ret *string) error
}
type StringService struct {
}
const (
StrMaxSize = 1024
)
var (
ErrMaxSize = errors.New(&amp;quot;over max size of 1024&amp;quot;)
ErrStrValue = errors.New(&amp;quot;maximum size of 1024 bytes exceeded&amp;quot;)
)
func (s StringService) Concat(req StringRequest, ret *string) error {
if len(req.A)+len(req.B) &amp;gt; StrMaxSize {
*ret = &amp;quot;&amp;quot;
return ErrMaxSize
}
*ret = req.A + req.B
return nil
}
func (s StringService) Diff(req StringRequest, ret *string) error {
if len(req.A) &amp;lt; 1 || len(req.B) &amp;lt; 1 {
*ret = &amp;quot;&amp;quot;
return nil
}
res := &amp;quot;&amp;quot;
if len(req.A) &amp;gt;= len(req.B) {
for _, char := range req.B {
if strings.Contains(req.A, string(char)) {
res = res + string(char)
}
}
} else {
for _, char := range req.A {
if strings.Contains(req.B, string(char)) {
res = res + string(char)
}
}
}
*ret = res
return nil
}
&lt;/code>&lt;/pre>
&lt;h3 id="maingo">main.go&lt;/h3>
&lt;pre>&lt;code>package main
import (
&amp;quot;log&amp;quot;
&amp;quot;net&amp;quot;
&amp;quot;net/http&amp;quot;
&amp;quot;net/rpc&amp;quot;
&amp;quot;rpc-server/service&amp;quot;
)
func main() {
stringService := new(service.StringService)
rpc.Register(stringService)
rpc.HandleHTTP()
l, e := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:1234&amp;quot;)
if e != nil {
log.Fatal(&amp;quot;listen error,&amp;quot;, e)
}
log.Println(&amp;quot;server at 127.0.0.1:1234&amp;quot;)
http.Serve(l, nil)
}
&lt;/code>&lt;/pre>
&lt;h2 id="client">Client&lt;/h2>
&lt;h3 id="servergo-1">server.go&lt;/h3>
&lt;pre>&lt;code>package service
type StringRequest struct {
A string
B string
}
&lt;/code>&lt;/pre>
&lt;h3 id="maingo-1">main.go&lt;/h3>
&lt;pre>&lt;code>package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;log&amp;quot;
&amp;quot;net/rpc&amp;quot;
&amp;quot;rpc-client/service&amp;quot;
)
func main() {
client, err := rpc.DialHTTP(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:1234&amp;quot;)
if err != nil {
log.Fatal(&amp;quot;dialing:&amp;quot;, err)
}
stringReq := &amp;amp;service.StringRequest{&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;}
var reply string
err = client.Call(&amp;quot;StringService.Concat&amp;quot;, stringReq, &amp;amp;reply)
if err != nil {
log.Fatal(&amp;quot;Concat err:&amp;quot;, err)
}
fmt.Printf(&amp;quot;StringService Concat : %s concat %s = %s\n&amp;quot;, stringReq.A, stringReq.B, reply)
stringReq = &amp;amp;service.StringRequest{&amp;quot;ABC&amp;quot;, &amp;quot;BCD&amp;quot;}
call := client.Go(&amp;quot;StringService.Diff&amp;quot;, stringReq, &amp;amp;reply, nil)
_ = &amp;lt;-call.Done
fmt.Printf(&amp;quot;StringService Diff : %s diff %s = %s\n&amp;quot;, stringReq.A, stringReq.B, reply)
}
&lt;/code>&lt;/pre></description></item><item><title>Golang中的Template模板引擎</title><link>https://chajiuqqq.github.io/blogs/p/golang%E4%B8%AD%E7%9A%84template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</link><pubDate>Thu, 23 Feb 2023 15:24:58 +0800</pubDate><guid>https://chajiuqqq.github.io/blogs/p/golang%E4%B8%AD%E7%9A%84template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</guid><description>&lt;ul>
&lt;li>&lt;a class="link" href="#%e5%a6%82%e4%bd%95%e8%af%bb%e5%8f%96%e6%a8%a1%e7%89%88%e5%b9%b6%e8%bf%94%e5%9b%9ehtml" >如何读取模版并返回HTML&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#template%e9%87%8c%e7%9a%84%e5%8a%a8%e4%bd%9c" >template里的动作&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#1-%e6%9d%a1%e4%bb%b6%e5%8a%a8%e4%bd%9c" >1. 条件动作&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#2-%e8%bf%ad%e4%bb%a3%e5%8a%a8%e4%bd%9c" >2. 迭代动作&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#3-%e8%ae%be%e7%bd%ae%e5%8a%a8%e4%bd%9c" >3. 设置动作&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#4-%e5%8c%85%e5%90%ab%e5%8a%a8%e4%bd%9c" >4. 包含动作&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="#%e5%8f%82%e6%95%b0" >参数&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#%e5%8f%98%e9%87%8f" >变量&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#%e7%ae%a1%e9%81%93" >管道&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#%e5%87%bd%e6%95%b0" >函数&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#%e4%b8%8a%e4%b8%8b%e6%96%87%e6%84%9f%e7%9f%a5" >上下文感知&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#%e5%8f%96%e6%b6%88html%e8%bd%ac%e4%b9%89" >取消HTML转义&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="#%e5%b5%8c%e5%a5%97%e6%a8%a1%e6%9d%bf" >嵌套模板&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#%e5%9d%97%e6%a8%a1%e6%9d%bf" >块模板&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="如何读取模版并返回html">如何读取模版并返回HTML&lt;/h1>
&lt;p>模版中的动作默认使用{{和}}包围，也可以自行修改界定符。&lt;code>{{.}}&lt;/code>指的是用传入的值替换这个动作本身。&lt;/p>
&lt;p>go web的模版引擎使用方法分为以下两个步骤：&lt;/p>
&lt;ul>
&lt;li>读取文本模版文件（或一个模版字符串），进行语法分析，创建一个模版结构。&lt;/li>
&lt;li>将数据传入，执行模版，生成HTML。&lt;/li>
&lt;/ul>
&lt;p>第一个步骤：&lt;/p>
&lt;pre>&lt;code>//从文件中生成模版
t,_ := template.ParseFiles(&amp;quot;index.html&amp;quot;)
//读取多个文件，但是只生成第一个文件的模板（因为第一个模版可能调用其他模版）
t,_ := template.ParseFiles(&amp;quot;index.html&amp;quot;,&amp;quot;content.html&amp;quot;,&amp;quot;navbar.html&amp;quot;)
//从字符串中生成模版
tmpl := `...`
t := template.New(&amp;quot;tmpl.html&amp;quot;)
t,_ = t.Parse(tmpl)
&lt;/code>&lt;/pre>
&lt;p>第二个步骤：&lt;/p>
&lt;pre>&lt;code>// t.Execute第一个参数是io.Writer，第二个参数是传入的数据。这个方法只会执行第一个模版，也就是index.html
t,_ := template.ParseFiles(&amp;quot;index.html&amp;quot;,&amp;quot;content.html&amp;quot;,&amp;quot;navbar.html&amp;quot;)
t.Execute(w,&amp;quot;hello world&amp;quot;)
//如果想要执行其他模板，用t.ExecuteTemplate,并在第二个参数指定模版名称
t,_ := template.ParseFiles(&amp;quot;index.html&amp;quot;,&amp;quot;content.html&amp;quot;,&amp;quot;navbar.html&amp;quot;)
t.ExecuteTemplate(w,&amp;quot;content.html&amp;quot;,&amp;quot;hello world&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>如果你只是在html中加入一些{{.}}的指令，模板的名称和文件名称一样，当然也可以重新定义模版的名字，或在一个模板文件中定义多个模板。&lt;/p>
&lt;p>注意传入的数据建议是指针，也就是加上数据的引用。并且在tmpl里调用func时，不会自动把x.field转为(&amp;amp;x).field，所以如果你定了一个结构的指针接受者方法，而传入tmpl一个值的数据，那么无法调用该方法。会提示在该类型中找不到该方法。&lt;/p>
&lt;pre>&lt;code>//t.ExecuteTemplate(w,&amp;quot;content.html&amp;quot;,Thread{})
t.ExecuteTemplate(w,&amp;quot;content.html&amp;quot;,&amp;amp;Thread{})
&lt;/code>&lt;/pre>
&lt;p>内嵌的field可以直接通过.调用，比如定义People和User：&lt;/p>
&lt;pre>&lt;code>type People struct{
Name string
}
type User struct{
People
Username string
Pwd string
}
&lt;/code>&lt;/pre>
&lt;p>在tmpl中，传入user，如果直接 {{.Name}}是可以获取的。&lt;/p>
&lt;p>&lt;strong>讲了这么多还不知道模版文件怎么写呢。下面讲讲动作语法。&lt;/strong>&lt;/p>
&lt;h1 id="template里的动作">template里的动作&lt;/h1>
&lt;p>如果要访问结构里的field，用：&lt;code>{{ .Name }}&lt;/code>，或 &lt;code>{{ .User.Name }}&lt;/code>&lt;/p>
&lt;h2 id="1-条件动作">1. 条件动作&lt;/h2>
&lt;p>接受true或false，从而决定执行（显示）哪条语句。下面如果传入true，则会显示content1语句。&lt;/p>
&lt;pre>&lt;code>{{ if . }}
content1
{{ else }}
content2
{{ end }}
&lt;/code>&lt;/pre>
&lt;h2 id="2-迭代动作">2. 迭代动作&lt;/h2>
&lt;p>可对传入的数组、切片、映射、或通道进行迭代，迭代里，&lt;code>.&lt;/code>会被设置为当前迭代的元素.&lt;code>else&lt;/code>用于当迭代的结构为空或nil时显示备选结果。&lt;/p>
&lt;pre>&lt;code>{{ range . }}
&amp;lt;li&amp;gt;The Elem: {{ . }} &amp;lt;/li&amp;gt;
{{ end }}
{{ range . }}
&amp;lt;li&amp;gt;The Elem: {{ . }} &amp;lt;/li&amp;gt;
{{ else }}
&amp;lt;li&amp;gt; No elems. &amp;lt;/li&amp;gt;
{{ end }}
&lt;/code>&lt;/pre>
&lt;h2 id="3-设置动作">3. 设置动作&lt;/h2>
&lt;p>类似if，&lt;code>{{if pipeline}} T1 {{end}}&lt;/code>,如果pipeline为空（false，0，nil，空的array, slice, map,string），则执行T0，否则执行T1.同时with里面{{.}}会被设置为pipeline的值。这是和if唯一的区别。&lt;/p>
&lt;pre>&lt;code>{{with pipeline}} T1 {{end}}
{{with pipeline}} T1 {{else}} T0 {{end}}
&lt;/code>&lt;/pre>
&lt;p>可以用来判断当某个集合为空时，显示xxx话。当不为空时，在with里用dot显示这个集合里的东西。&lt;/p>
&lt;h2 id="4-包含动作">4. 包含动作&lt;/h2>
&lt;p>可以在一个模板里包含另一个模板，用到&lt;code>{{ template &amp;quot;name&amp;quot; }}&lt;/code>,或&lt;code>{{template &amp;quot;name&amp;quot; pipeline}}&lt;/code>&lt;/p>
&lt;p>第一个参数是模板的名字（如果没定义，那就是模板文件名称），第二个参数是要传给这下一个模板的参数。&lt;/p>
&lt;p>通常这么用：&lt;code>{{template &amp;quot;name&amp;quot; . }}&lt;/code>&lt;/p>
&lt;h1 id="参数">参数&lt;/h1>
&lt;p>上述的if后边跟的就是arg参数，这边传了dot过去。&lt;/p>
&lt;pre>&lt;code>{{ if . }}
content1
{{ else }}
content2
{{ end }}
&lt;/code>&lt;/pre>
&lt;p>arg可以是一个值，一个变量，或一个返回一个值的函数。&lt;/p>
&lt;p>如：&lt;/p>
&lt;pre>&lt;code>{{ if . }} content1 {{ end }}
{{ if $key }} content1 {{ end }}
{{ if .IsExist }} content1 {{ end }}
&lt;/code>&lt;/pre>
&lt;h1 id="变量">变量&lt;/h1>
&lt;p>可以在动作中设置变量：&lt;code>$key := something&lt;/code>,如：&lt;/p>
&lt;pre>&lt;code>{{ range $key, $value := . }}
&amp;lt;li&amp;gt;{{ $key }} : {{ $value }} &amp;lt;/li&amp;gt;
{{ end }}
&lt;/code>&lt;/pre>
&lt;h1 id="管道">管道&lt;/h1>
&lt;p>管道可以串联参数和函数、方法。如&lt;/p>
&lt;pre>&lt;code>{{ p1 | p2 | p3 }}
&lt;/code>&lt;/pre>
&lt;p>这三者都是参数。&lt;/p>
&lt;pre>&lt;code>{{ 123.456 | printf &amp;quot;%.2f&amp;quot; }}
&lt;/code>&lt;/pre>
&lt;p>将123.456传给&lt;strong>模板内置printf函数&lt;/strong>&lt;/p>
&lt;p>当然函数也可以通过后置参数调用：&lt;/p>
&lt;pre>&lt;code>{{ printf &amp;quot;%.2f&amp;quot; 123.456 }}
&lt;/code>&lt;/pre>
&lt;h1 id="函数">函数&lt;/h1>
&lt;p>模板引擎里的内置函数虽然可以接受多个参数，但是只能返回一个值，或返回一个值+一个错误。内置函数列表见 &lt;a class="link" href="https://pkg.go.dev/text/template#hdr-Functions" target="_blank" rel="noopener"
>https://pkg.go.dev/text/template#hdr-Functions&lt;/a>&lt;/p>
&lt;p>用户可以自定义函数并传入模板，步骤如下：&lt;/p>
&lt;ol>
&lt;li>创建一个FuncMap，并传入&lt;code>函数名称：真的函数名&lt;/code>，后面模板里就用函数名称进行调用&lt;/li>
&lt;li>将FuncMap和模板绑定&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/1.png"
width="1000"
height="430"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/1_huef1bbdaf32f80678fafa93f55074d365_190394_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/1_huef1bbdaf32f80678fafa93f55074d365_190394_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="232"
data-flex-basis="558px"
>&lt;/p>
&lt;p>调用：&lt;/p>
&lt;pre>&lt;code>{{ . | fdate }}
或
{{ fdate . }}
&lt;/code>&lt;/pre>
&lt;p>还有些参数、变量、管道和函数这里先略过。&lt;/p>
&lt;h1 id="上下文感知">上下文感知&lt;/h1>
&lt;p>go模板里动作的输出会根据所处的上下文改变输出形态，如&lt;/p>
&lt;ul>
&lt;li>{{ . }}在HTML处，会将输出进行html转译后输出&lt;/li>
&lt;li>{{ . }}在href或src处，会将输出进行URL转译后输出&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/2.png"
width="1536"
height="426"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/2_hu7ca5a1e6d4d0f62c5bd7a77332d8f790_495731_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/2_hu7ca5a1e6d4d0f62c5bd7a77332d8f790_495731_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="360"
data-flex-basis="865px"
>&lt;/p>
&lt;p>这主要用于实现自动防御编程，可以抵御XSS攻击。&lt;/p>
&lt;h2 id="取消html转义">取消HTML转义&lt;/h2>
&lt;p>使用&lt;code>template.HTML()&lt;/code>包裹值并传入模板即可。如&lt;code>template.HTML(r.FormValue(&amp;quot;comment&amp;quot;))&lt;/code>&lt;/p>
&lt;h1 id="嵌套模板">嵌套模板&lt;/h1>
&lt;p>通常我们会在网站开发中复用某套layout，如有导航栏，服务器状态，版权声明。然后中间是展示的内容。如果要实现内容替换而其他东西复用，我们就不能使用默认的模板名字。比如下面这个lauout.html&lt;/p>
&lt;pre>&lt;code>&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=9&amp;quot;&amp;gt;
&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;ChitChat&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
{{ template &amp;quot;content.html&amp;quot; }}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>这里嵌套了&amp;quot;content.html&amp;quot;模板。问题是只有唯一一个&amp;quot;content.html&amp;quot;，这么写除了把一个文件拆成两个文件，无法复用layout.html。于是我们可以定义模板名称，而不是用默认的文件名：&lt;/p>
&lt;pre>&lt;code>&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=9&amp;quot;&amp;gt;
&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;ChitChat&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
{{ template &amp;quot;content&amp;quot; }}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>然后在index.html中定义一个模板为content：&lt;/p>
&lt;pre>&lt;code>{{ define &amp;quot;content&amp;quot; }}
&amp;lt;p class=&amp;quot;lead&amp;quot;&amp;gt;
&amp;lt;a href=&amp;quot;/thread/new&amp;quot;&amp;gt;Start a thread&amp;lt;/a&amp;gt; or join one below!
&amp;lt;/p&amp;gt;
{{ end }}
&lt;/code>&lt;/pre>
&lt;p>parseFiles时传入layout.html和index.html，就可以实现模板嵌入。&lt;/p>
&lt;p>同理，我们还可以定义另一个login.html,并在其中定义content：&lt;/p>
&lt;pre>&lt;code>{{ define &amp;quot;content&amp;quot; }}
&amp;lt;a href=&amp;quot;/login&amp;quot;&amp;gt;Login！&amp;lt;/a&amp;gt;
{{ end }}
&lt;/code>&lt;/pre>
&lt;p>parseFiles时传入layout.html和login.html，就可以实现另一个模板的嵌入。&lt;/p>
&lt;p>如果模板名字不同，也可以在同一个文件里定义多个不同的模板；可以在多个文件里定义同名模板。&lt;/p>
&lt;h2 id="块模板">块模板&lt;/h2>
&lt;p>这是另一种定义模板的方法。主要用于直接在一个模板中定义新的模板，并且作为缺省模板使用。&lt;/p>
&lt;pre>&lt;code>{{ define &amp;quot;layout&amp;quot; }}
hello
{{ block &amp;quot;content&amp;quot; . }}
&amp;lt;p&amp;gt;someone!&amp;lt;/p&amp;gt;
{{ end }}
{{ end }}
&lt;/code>&lt;/pre>
&lt;p>如果在parseFiles时没有传入额外的content模板，则会使用layout里定义的content块作为缺省使用。&lt;/p></description></item><item><title>Golang中的应用测试</title><link>https://chajiuqqq.github.io/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/</link><pubDate>Wed, 15 Feb 2023 11:31:41 +0800</pubDate><guid>https://chajiuqqq.github.io/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/</guid><description>&lt;p>本文记录了一下内容：&lt;/p>
&lt;ul>
&lt;li>golang的单元测试、基准测试、http测试&lt;/li>
&lt;li>测试替身和依赖注入&lt;/li>
&lt;li>第三方Go测试库，gocheck，ginkgo&lt;/li>
&lt;/ul>
&lt;p>目录：&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="#go%e5%ba%94%e7%94%a8%e6%b5%8b%e8%af%95%e6%a6%82%e8%bf%b0" >go应用测试概述&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95" >单元测试&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#%e8%b7%b3%e8%bf%87%e6%b5%8b%e8%af%95%e7%94%a8%e4%be%8b" >跳过测试用例&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#%e8%ae%be%e7%bd%ae%e5%b9%b6%e8%a1%8c%e8%bf%90%e8%a1%8c%e7%9a%84%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95%e6%95%b0%e9%87%8f" >设置并行运行的单元测试数量&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="#%e5%9f%ba%e5%87%86%e6%b5%8b%e8%af%95" >基准测试&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#%e5%a6%82%e4%bd%95%e6%b5%8b%e8%af%95http" >如何测试http&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%87%bd%e6%95%b0%e6%88%91%e8%87%aa%e5%b7%b1%e5%8f%96%e7%9a%84%e5%90%8d%e5%ad%97" >生命周期函数（我自己取的名字）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="#%e6%b5%8b%e8%af%95%e6%9b%bf%e8%ba%ab%e5%92%8c%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5" >测试替身和依赖注入&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#%e7%ac%ac%e4%b8%89%e6%96%b9go%e6%a3%80%e6%b5%8b%e5%ba%93" >第三方go检测库&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#gocheck" >gocheck&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#ginkgo" >ginkgo&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="go应用测试概述">go应用测试概述&lt;/h2>
&lt;p>go的testing包用于测试，net/http/httptest用于测试web程序。对于源码文件server.go，可以在同目录下创建server_test.go文件，定义func TestXxx(*testing.T)函数。函数内部使用Error、Fail等方法表示测试失败，如果测试时没有出现任何失败，则表示测试通过。&lt;/p>
&lt;p>编写完测试文件后，在当前目录下用&lt;code>go test&lt;/code>测试所有测试文件。&lt;/p>
&lt;h3 id="单元测试">单元测试&lt;/h3>
&lt;p>如果一个部分能独立进行测试，那被称为“单元”。向单元输入数据，并检查输出是否符合预期就是单元测试。&lt;/p>
&lt;p>testing.T中的有用的方法：&lt;/p>
&lt;ul>
&lt;li>Log，Logf：把文本记录到错误日志中，不终止测试&lt;/li>
&lt;li>Fail：标记当前测试单元“失败”&lt;/li>
&lt;li>FailNow：标记当前测试函数“失败”，并终止当前测试单元&lt;/li>
&lt;/ul>
&lt;p>Error,Errorf,Fatal,Fatalf是上述函数的复合，见下表。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">&lt;/th>
&lt;th style="text-align:left">Log&lt;/th>
&lt;th style="text-align:left">Logf&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">Fail&lt;/td>
&lt;td style="text-align:left">Error&lt;/td>
&lt;td style="text-align:left">Errorf&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">FailNow&lt;/td>
&lt;td style="text-align:left">Fatal&lt;/td>
&lt;td style="text-align:left">Fatalf&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>这些方法只对当前单元有效。&lt;/p>
&lt;p>单元测试中的命令：&lt;/p>
&lt;ul>
&lt;li>&lt;code>-v&lt;/code>获取详细测试信息&lt;/li>
&lt;li>&lt;code>-cover&lt;/code>输出代码覆盖率&lt;/li>
&lt;/ul>
&lt;p>如&lt;code>go test -v -cover&lt;/code>&lt;/p>
&lt;h4 id="跳过测试用例">跳过测试用例&lt;/h4>
&lt;p>如果在单元测试中调用&lt;code>t.Skip()&lt;/code>函数，则会在执行到这一行时跳过该测试单元的其余部分。&lt;/p>
&lt;p>命令中也提供这么个flag，用于逻辑判断：&lt;code>-short&lt;/code>，当设置了&lt;code>-short&lt;/code>时（如&lt;code>go test -v -cover -short&lt;/code>），代码中调用testing.Short()返回true.&lt;/p>
&lt;p>将&lt;code>-short&lt;/code>和&lt;code>t.Skip()&lt;/code>结合使用，可实现命令行控制是否跳过某些测试函数，如：&lt;/p>
&lt;pre>&lt;code>func TestXxxx(t *testing.T){
if testing.Short(){
t.Skip(&amp;quot;skip for short flag.&amp;quot;)
}
...
}
&lt;/code>&lt;/pre>
&lt;h4 id="设置并行运行的单元测试数量">设置并行运行的单元测试数量&lt;/h4>
&lt;p>利用&lt;code>-parallel n&lt;/code>设置并行运行的单元测试数量。如&lt;code>go test -v -parallel 3&lt;/code>表示最多并行运行3个单元测试。&lt;/p>
&lt;h3 id="基准测试">基准测试&lt;/h3>
&lt;p>利用&lt;code>-bench [函数名的正则表达式]&lt;/code>flag，执行*_test.go中定义的基准函数的测试，用于评估函数的性能。基准函数格式：&lt;/p>
&lt;pre>&lt;code>func BenchmarkXxx(*testing.B){...}
&lt;/code>&lt;/pre>
&lt;p>通常在其中添加循环，执行&lt;code>b.N&lt;/code>次程序，以此观察程序性能：&lt;/p>
&lt;pre>&lt;code>func BenchmarkXxx(b *testing.B){
for i:=0;i&amp;lt;b.N;i++{
...
}
}
&lt;/code>&lt;/pre>
&lt;p>执行所有单元测试和基准函数：&lt;code>go test -v -bench .&lt;/code>&lt;/p>
&lt;p>如要忽略单元测试，使用&lt;code>-run [函数名的正则表达式]&lt;/code>来指定要运行的单元测试。设置为&lt;code>-run none&lt;/code>则会忽略所有单元测试。结合一下，&lt;code>go test -v -run none -bench .&lt;/code>就只会执行基准测试了。&lt;/p>
&lt;h3 id="如何测试http">如何测试http&lt;/h3>
&lt;p>测试http就是在测试处理器函数，这种函数接受http.ResponseWriter和*http.Request.问题在于如何提供这两个参数。我们可以在测试函数中伪造http server、http请求，并把response记录下来，实现伪造http整个流程，从而实现测试。&lt;/p>
&lt;p>下面代码实现了对处理器函数的测试：&lt;/p>
&lt;ol>
&lt;li>伪造一个http server&lt;/li>
&lt;li>指定要测试的处理器函数和路径&lt;/li>
&lt;li>伪造GET请求&lt;/li>
&lt;li>把response记录在httptest.ResponseRecorder中&lt;/li>
&lt;li>读取response，看程序是否符合预期&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>func TestHandleGet(t *testing.T) {
mux := http.NewServeMux()
mux.HandleFunc(&amp;quot;/post/&amp;quot;, handleRequest)
writer := httptest.NewRecorder()
req, _ := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;/post/1&amp;quot;, nil)
mux.ServeHTTP(writer, req)
if writer.Code != 200 {
t.Errorf(&amp;quot;response code is %d&amp;quot;, writer.Code)
}
var post data.Post
json.Unmarshal(writer.Body.Bytes(), &amp;amp;post)
if post.Id != 1 {
t.Error(&amp;quot;can't retrieve JSON post&amp;quot;)
}
}
&lt;/code>&lt;/pre>
&lt;h4 id="生命周期函数我自己取的名字">生命周期函数（我自己取的名字）&lt;/h4>
&lt;p>为了在测试前、测试后统一执行一些共有的代码，可以利用生命周期函数实现。首先定义函数TestMain&lt;/p>
&lt;pre>&lt;code>func TestMain(m *testing.M) {
setUp()
code := m.Run()
tearDown()
os.Exit(code)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>setUp()&lt;/code>和&lt;code>tearDown()&lt;/code>都是为所有测试用例定义的函数，m.Run()会调用测试案例，所以&lt;code>setUp()&lt;/code>在测试前执行，&lt;code>tearDown()&lt;/code>在测试后执行。&lt;strong>并且在整个测试中只会执行一次。&lt;/strong>&lt;/p>
&lt;p>上述TestHandleGet方法我们也可以优化为：&lt;/p>
&lt;pre>&lt;code>var mux *http.ServeMux
var writer *httptest.ResponseRecorder
func TestMain(m *testing.M) {
setUp()
code := m.Run()
os.Exit(code)
}
func setUp() {
mux = http.NewServeMux()
mux.HandleFunc(&amp;quot;/post/&amp;quot;, handleRequest)
writer = httptest.NewRecorder()
}
func TestHandleGet(t *testing.T) {
req, _ := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;/post/1&amp;quot;, nil)
mux.ServeHTTP(writer, req)
if writer.Code != 200 {
t.Errorf(&amp;quot;response code is %d&amp;quot;, writer.Code)
}
var post data.Post
json.Unmarshal(writer.Body.Bytes(), &amp;amp;post)
if post.Id != 1 {
t.Error(&amp;quot;can't retrieve JSON post&amp;quot;)
}
}
&lt;/code>&lt;/pre>
&lt;p>这样就把mux和writer作为全局变量。测试开始前进行初始化设置。&lt;/p>
&lt;h2 id="测试替身和依赖注入">测试替身和依赖注入&lt;/h2>
&lt;p>为了不在测试中执行真实的操作，如测试邮件发送不希望真的发送邮件；测试数据库不希望真的修改数据库（某些场景下），我们需要用接口来实现依赖注入（替换实际对象），由依赖关系代替实际的操作，实现层的解耦。&lt;/p>
&lt;h2 id="第三方go检测库">第三方go检测库&lt;/h2>
&lt;h3 id="gocheck">gocheck&lt;/h3>
&lt;p>这是一个基于testing构建的测试框架。安装：&lt;code>go get gopkg.in/check.v1&lt;/code>&lt;/p>
&lt;p>有几个特点：&lt;/p>
&lt;ul>
&lt;li>以suite为单位分组测试（测试某个结构里的所有测试方法）&lt;/li>
&lt;li>suite或单个测试用例粒度的生命周期函数（测试夹具）&lt;/li>
&lt;li>。。。&lt;/li>
&lt;/ul>
&lt;p>使用例子，只有注册过的Suite才会被测试：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">import(
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> . &amp;#34;gopkg.in/check.v1&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//定义suite
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">type XxxSuite struct{}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//注册suite,只有注册过的Suite才会被测试
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">func init(){
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Suite(&amp;amp;XxxSuite{})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//定义suite里的测试方法
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">func (x *XxxSuite) TestHandleGet(c *C){
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> c.Check(code,Equals,200)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>go test -check.vv&lt;/code> 会显示更详细的日志&lt;/p>
&lt;p>测试夹具（预定义的生命周期函数）：&lt;/p>
&lt;ul>
&lt;li>suite粒度（当前套件执行前后调用）
&lt;ul>
&lt;li>SetUpSuite&lt;/li>
&lt;li>TearDownSuite&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>测试用例粒度（当前套件的每个测试用例执行前后调用）
&lt;ul>
&lt;li>SetUpTest&lt;/li>
&lt;li>TearDownTest&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>注意这几个函数需要定义在suite内，如：&lt;code>func (x *XxxSuite) SetUpSuite(c *C){}&lt;/code> &lt;code>func (x *XxxSuite) SetUpTest(c *C){}&lt;/code>&lt;/p>
&lt;h3 id="ginkgo">ginkgo&lt;/h3>
&lt;p>一个行为驱动开发（BDD）风格的Go测试框架。主要用于实现BDD，但是这里只用作测试框架使用。&lt;/p>
&lt;p>BDD，软件由目标行为定义。这些行为也就是业务需求，如：&lt;/p>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/bdd.png"
width="360"
height="288"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/bdd_hu562acb1999a1026474a0aa02db55fa8e_62212_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/bdd_hu562acb1999a1026474a0aa02db55fa8e_62212_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="125"
data-flex-basis="300px"
>&lt;/p>
&lt;p>&lt;strong>1、用ginkgo转换已存在的测试用例为BDD风格&lt;/strong>&lt;/p>
&lt;p>在包含测试文件的目录下执行&lt;code>ginkgo convert .&lt;/code>，会生成&lt;code>xxx_suite_test.go&lt;/code>（相当于原来testing的入口），并对原&lt;code>xxx_test.go&lt;/code>进行修改，因此注意备份。&lt;/p>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo1.png"
width="415"
height="295"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo1_hucd32dd84a59b21270f8fc958c69c4140_58233_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo1_hucd32dd84a59b21270f8fc958c69c4140_58233_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="140"
data-flex-basis="337px"
>&lt;/p>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo2.png"
width="593"
height="379"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo2_hu58542b68b29aee11689b241cf1f01267_101146_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo2_hu58542b68b29aee11689b241cf1f01267_101146_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="156"
data-flex-basis="375px"
>&lt;/p>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo3.png"
width="661"
height="645"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo3_hu2b74b3cdcd9234ac0a5a7164ffd9d132_170488_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo3_hu2b74b3cdcd9234ac0a5a7164ffd9d132_170488_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="102"
data-flex-basis="245px"
>&lt;/p>
&lt;p>&lt;strong>2、自己编写ginkgo用例&lt;/strong>&lt;/p>
&lt;p>用到2个命令：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ginkgo bootstrap&lt;/code>:创建引导文件（我取的名字），类似&lt;code>xxx_suite_test.go&lt;/code>&lt;/li>
&lt;li>&lt;code>ginkgo generate&lt;/code>:创建测试用例文件的骨架：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo4.png"
width="428"
height="254"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo4_hu9c5292ea206b45f2fa38342a582ec3ea_59200_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo4_hu9c5292ea206b45f2fa38342a582ec3ea_59200_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="168"
data-flex-basis="404px"
>&lt;/p>
&lt;p>这里首先再导入一个断言包Gomega，为啥要用这个呢，可能功能更强大吧。&lt;/p>
&lt;p>&lt;code>go get github.com/onsi/gomega&lt;/code>&lt;/p>
&lt;p>接下来就在这个Describe函数里描述用户故事、情景。也就是用他给定的格式写测试代码。&lt;/p>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo5.png"
width="816"
height="913"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo5_hudf13b97f83400c128b950d090612810f_267180_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo5_hudf13b97f83400c128b950d090612810f_267180_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="89"
data-flex-basis="214px"
>&lt;/p>
&lt;p>当然ginkgo的测试夹具（预定义的生命周期函数）也不可少，&lt;code>BeforeEach()&lt;/code>会在每个&lt;code>情景&lt;/code>前执行(也就是每个context函数前执行)：&lt;/p>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo6.png"
width="719"
height="199"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo6_hu17f44393d4b37e520a6c6d067c66257d_69463_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo6_hu17f44393d4b37e520a6c6d067c66257d_69463_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="361"
data-flex-basis="867px"
>&lt;/p></description></item><item><title>Golang中的数据存储</title><link>https://chajiuqqq.github.io/blogs/p/golang%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</link><pubDate>Sun, 12 Feb 2023 08:47:06 +0800</pubDate><guid>https://chajiuqqq.github.io/blogs/p/golang%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</guid><description>&lt;p>Golang中的数据存储有三种方案：&lt;/p>
&lt;ul>
&lt;li>利用容器的内存存储（非内存数据库）&lt;/li>
&lt;li>利用文件读写的存储（文本文件如csv、二进制文件如gob）&lt;/li>
&lt;li>数据库存储&lt;/li>
&lt;/ul>
&lt;p>本文简述后面两种。&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="#%e6%96%87%e4%bb%b6%e5%ad%98%e5%82%a8" >文件存储&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#csv%e8%af%bb%e5%86%99" >csv读写&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#gob%e8%af%bb%e5%86%99" >gob读写&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="#%e5%88%a9%e7%94%a8databasesql%e8%bf%9e%e6%8e%a5%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e6%89%a7%e8%a1%8ccrud" >利用database/sql连接数据库并执行CRUD&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#go-orm-%e5%85%b3%e7%b3%bb%e6%98%a0%e5%b0%84%e5%99%a8" >go orm 关系映射器&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#%e5%ae%89%e8%a3%85" >安装&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#%e8%bf%9e%e6%8e%a5%e6%95%b0%e6%8d%ae%e5%ba%93" >连接数据库&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#%e6%a8%a1%e5%9e%8b%e5%a3%b0%e6%98%8e" >模型声明&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#%e9%a2%84%e5%8a%a0%e8%bd%bd" >预加载&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#%e5%85%b3%e8%81%94%e6%a8%a1%e5%bc%8f" >关联模式&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="文件存储">文件存储&lt;/h1>
&lt;p>下面展示了golang中读写文件的常用方式。&lt;/p>
&lt;ul>
&lt;li>ioutil的函数读写文件&lt;/li>
&lt;li>os创建File，再读写文件&lt;/li>
&lt;/ul>
&lt;p>code:&lt;/p>
&lt;pre>&lt;code>package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;io/ioutil&amp;quot;
&amp;quot;os&amp;quot;
)
func main() {
//ioutil读写文件
data := []byte(&amp;quot;hello world!&amp;quot;)
err := ioutil.WriteFile(&amp;quot;data1&amp;quot;, data, 0644)
if err != nil {
panic(err)
}
read1, _ := ioutil.ReadFile(&amp;quot;data1&amp;quot;)
fmt.Println(string(read1))
//os读写文件
file1, _ := os.Create(&amp;quot;data2&amp;quot;)
defer file1.Close()
nbytes, _ := file1.Write(data)
fmt.Printf(&amp;quot;wrote %d bytes to file\n&amp;quot;, nbytes)
file2, _ := os.Open(&amp;quot;data2&amp;quot;)
defer file2.Close()
read2 := make([]byte, len(data))
nbytes, _ = file2.Read(read2)
fmt.Printf(&amp;quot;Read %d bytes from file\n&amp;quot;, nbytes)
fmt.Println(string(read2))
}
//
hello world!
wrote 12 bytes to file
Read 12 bytes from file
hello world!
&lt;/code>&lt;/pre>
&lt;h2 id="csv读写">csv读写&lt;/h2>
&lt;p>利用&amp;quot;encoding/csv&amp;quot;可实现csv读写，下面是小例子。将File传给csv.NewWriter()或csv.NewReader()&lt;/p>
&lt;pre>&lt;code>package main
import (
&amp;quot;encoding/csv&amp;quot;
&amp;quot;fmt&amp;quot;
&amp;quot;os&amp;quot;
&amp;quot;strconv&amp;quot;
)
type Post struct {
Id int
Content string
Author string
}
func main() {
csvFile, err := os.Create(&amp;quot;posts.csv&amp;quot;)
if err != nil {
panic(err)
}
defer csvFile.Close()
allPosts := []Post{
Post{1, &amp;quot;hello world 1&amp;quot;, &amp;quot;Jack1&amp;quot;},
Post{2, &amp;quot;hello world 2&amp;quot;, &amp;quot;Jack2&amp;quot;},
Post{3, &amp;quot;hello world 3&amp;quot;, &amp;quot;Jack3&amp;quot;},
Post{4, &amp;quot;hello world 4&amp;quot;, &amp;quot;Jack4&amp;quot;},
Post{5, &amp;quot;hello world 5&amp;quot;, &amp;quot;Jack5&amp;quot;},
}
writer := csv.NewWriter(csvFile)
for _, post := range allPosts {
line := []string{strconv.Itoa(post.Id), post.Content, post.Author}
if err := writer.Write(line); err != nil {
panic(err)
}
}
writer.Flush()
file, err := os.Open(&amp;quot;posts.csv&amp;quot;)
if err != nil {
panic(err)
}
defer file.Close()
reader := csv.NewReader(file)
reader.FieldsPerRecord = -1
records, err := reader.ReadAll()
if err != nil {
panic(err)
}
var posts []Post
for _, item := range records {
id, _ := strconv.Atoi(item[0])
post := Post{id, item[1], item[2]}
posts = append(posts, post)
}
fmt.Println(posts[0].Id)
fmt.Println(posts[0].Content)
fmt.Println(posts[0].Author)
}
&lt;/code>&lt;/pre>
&lt;p>生成posts.csv:&lt;/p>
&lt;pre>&lt;code>1,hello world 1,Jack1
2,hello world 2,Jack2
3,hello world 3,Jack3
4,hello world 4,Jack4
5,hello world 5,Jack5
&lt;/code>&lt;/pre>
&lt;h2 id="gob读写">gob读写&lt;/h2>
&lt;p>利用&amp;quot;encoding/gob&amp;quot;包，gob.NewEncoder()接受一个io.Writer; gob.NewDecoder()接受一个io.Reader.&lt;/p>
&lt;p>也就是说，可以提供一个buffer，供编码时存储结果；供解码时存储输入。&lt;/p>
&lt;p>最后传入&lt;code>&amp;amp;postRecord&lt;/code>才能修改原变量内容。&lt;/p>
&lt;pre>&lt;code>package main
import (
&amp;quot;bytes&amp;quot;
&amp;quot;encoding/gob&amp;quot;
&amp;quot;fmt&amp;quot;
&amp;quot;io/ioutil&amp;quot;
)
type Post struct {
Id int
Content string
Author string
}
func store(data interface{}, filename string) {
buffer := new(bytes.Buffer)
encoder := gob.NewEncoder(buffer)
err := encoder.Encode(data)
if err != nil {
panic(err)
}
err = ioutil.WriteFile(filename, buffer.Bytes(), 0600)
if err != nil {
panic(err)
}
}
func load(data interface{}, filename string) {
raw, err := ioutil.ReadFile(filename)
if err != nil {
panic(err)
}
buffer := bytes.NewBuffer(raw)
decoder := gob.NewDecoder(buffer)
err = decoder.Decode(data)
if err != nil {
panic(err)
}
}
func main() {
post := Post{1, &amp;quot;hello world&amp;quot;, &amp;quot;jack&amp;quot;}
store(post, &amp;quot;post1&amp;quot;)
var postRecord Post
load(&amp;amp;postRecord, &amp;quot;post1&amp;quot;)
fmt.Println(postRecord)
}
&lt;/code>&lt;/pre>
&lt;h1 id="利用databasesql连接数据库并执行crud">利用database/sql连接数据库并执行CRUD&lt;/h1>
&lt;p>首先需要注入对应的数据库驱动，如postgres常用github.com/lib/pq驱动。在main包中注入：&lt;/p>
&lt;pre>&lt;code>import(
_ &amp;quot;github.com/lib/pq&amp;quot;
)
&lt;/code>&lt;/pre>
&lt;p>数据库连接，使用sql.Open(数据库名称，数据源字符串)，其中数据源字符串需要符合对应驱动的格式，如pq的话，有这么几种合法的格式：&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;user=pqgotest dbname=pqgotest sslmode=verify-full&amp;rdquo;&lt;/li>
&lt;li>&amp;ldquo;postgres://pqgotest:password@localhost/pqgotest?sslmode=verify-full&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;p>见 &lt;a class="link" href="https://pkg.go.dev/github.com/lib/pq" target="_blank" rel="noopener"
>https://pkg.go.dev/github.com/lib/pq&lt;/a>&lt;/p>
&lt;p>CRUD总结：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>预处理语句：使用sql.Stmt结构&lt;/p>
&lt;pre>&lt;code> stmt,err := db.Prepare(&amp;quot;...&amp;quot;)
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>执行语句并获取一个sql.Row,一般后跟Scan(),用于把这一行读取到某些变量中&lt;/p>
&lt;pre>&lt;code> db.QueryRow(&amp;quot;...&amp;quot;, , )
或
stmt.QueryRow( , )
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>执行并获取多个sql.Row:&lt;/p>
&lt;pre>&lt;code> rows,err := db.Query(&amp;quot;...&amp;quot;, , )
rows.Next()
rows.Scan()
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>直接执行语句，只返回最后插入ID(如果insert)、影响的行数（insert、update、delete），不返回查询结果：&lt;/p>
&lt;pre>&lt;code> res,err := db.Exec(&amp;quot;...&amp;quot;, , )
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h1 id="go-orm-关系映射器">go orm 关系映射器&lt;/h1>
&lt;p>ORM 思想是将数据结构和表结构相对应。Gorm是go里最棒的ORM。下面介绍Gorm的大概用法，具体可见文档 &lt;a class="link" href="https://gorm.io/zh_CN/docs/index.html" target="_blank" rel="noopener"
>https://gorm.io/zh_CN/docs/index.html&lt;/a>&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>需要安装gorm和对应的数据库驱动&lt;/p>
&lt;pre>&lt;code>go get -u gorm.io/gorm
go get -u gorm.io/driver/postgres
&lt;/code>&lt;/pre>
&lt;h2 id="连接数据库">连接数据库&lt;/h2>
&lt;p>一般在init中执行连接和数据库自动迁移：&lt;/p>
&lt;pre>&lt;code>func init() {
var err error
dsn := &amp;quot;user=postgres password=mkQ445683 dbname=chitchat sslmode=disable&amp;quot;
Db, err = gorm.Open(postgres.Open(dsn), &amp;amp;gorm.Config{})
if err != nil {
log.Fatal(err)
}
Db.AutoMigrate(&amp;amp;Post{}, &amp;amp;Thread{}, &amp;amp;Session{}, &amp;amp;User{})
}
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>迁移：Db.AutoMigrate()，AutoMigrate 会创建表、缺失的外键、约束、列和索引，出于保护您数据的目的，它&lt;strong>不会&lt;/strong>删除未使用的列&lt;/p>
&lt;p>db.AutoMigrate(&amp;amp;User{})&lt;/p>
&lt;p>db.AutoMigrate(&amp;amp;User{}, &amp;amp;Product{}, &amp;amp;Order{})&lt;/p>
&lt;/blockquote>
&lt;h2 id="模型声明">模型声明&lt;/h2>
&lt;p>Gorm默认用ID作为主键，使用结构体名的 &lt;code>蛇形复数&lt;/code> 作为表名，字段名的 &lt;code>蛇形&lt;/code> 作为列名，并使用 CreatedAt、UpdatedAt 字段追踪创建、更新时间&lt;/p>
&lt;p>如：MemberNumber &amp;ndash;&amp;gt; member_number; CreatedAt &amp;ndash;&amp;gt; created_at&lt;/p>
&lt;p>通常将gorm.Model嵌入自己的结构体中，如：&lt;/p>
&lt;pre>&lt;code>User struct {
gorm.Model
Uuid string
Name string
Email string
Password string
}
&lt;/code>&lt;/pre>
&lt;p>gorm.Model包括字段 ID、CreatedAt、UpdatedAt、DeletedAt，所以你的结构体也会包含这些字段。对于包含的field，也可以用标签embedded嵌入：&lt;/p>
&lt;pre>&lt;code>type Blog struct {
ID int
Author Author `gorm:&amp;quot;embedded&amp;quot;`
Upvotes int32
}
&lt;/code>&lt;/pre>
&lt;h2 id="预加载">预加载&lt;/h2>
&lt;p>首先我们定义User、Order、City. User和Order是一对多关系，User和City是一对一关系。&lt;/p>
&lt;pre>&lt;code>type User struct {
gorm.Model
Username string
Orders []Order
City City
}
type Order struct {
gorm.Model
UserID uint
Price float64
}
type City struct{
gorm.Model
UserID uint
Name string
}
&lt;/code>&lt;/pre>
&lt;p>这种关系由外键定义，Gorm默认会将类似UserID识别为User的外键。所以上述关系会被Gorm建立。&lt;/p>
&lt;p>同时我们可以在&lt;code>User&lt;/code>里包含&lt;code>[]Order&lt;/code>和&lt;code>City&lt;/code>，这很方便我们获取和User相关联的对象。如果仅仅通过&lt;/p>
&lt;pre>&lt;code>users := []User{}
db.Find(&amp;amp;users)
&lt;/code>&lt;/pre>
&lt;p>无法加载&lt;code>[]Order&lt;/code>和&lt;code>City&lt;/code>。一个加载内在关联的对象的方法是&lt;code>预加载Preload&lt;/code>：&lt;/p>
&lt;pre>&lt;code>users := []User{}
db.Preload(&amp;quot;Orders&amp;quot;).Preload(&amp;quot;City&amp;quot;).Find(&amp;amp;users)
&lt;/code>&lt;/pre>
&lt;p>通过在Preload里指定结构字段名，再查询，Gorm会自动加载对应关联的对象。这样我们就可以获得User和与其匹配的Orders和City。&lt;/p>
&lt;p>&lt;strong>1、条件预加载&lt;/strong>&lt;/p>
&lt;p>上述Preload会匹配所有UserID符合的Order，如果想进一步添加约束条件，如已完成的Order，如何实现？可以用条件预加载：&lt;/p>
&lt;pre>&lt;code>db.Preload(&amp;quot;Orders&amp;quot;, &amp;quot;state=?&amp;quot;, &amp;quot;completed&amp;quot;).Find(&amp;amp;users)
// SELECT * FROM users;
// SELECT * FROM orders WHERE user_id IN (1,2,3,4) AND state NOT IN ('cancelled');
db.Where(&amp;quot;state = ?&amp;quot;, &amp;quot;active&amp;quot;).Preload(&amp;quot;Orders&amp;quot;, &amp;quot;state NOT IN (?)&amp;quot;, &amp;quot;cancelled&amp;quot;).Find(&amp;amp;users)
// SELECT * FROM users WHERE state = 'active';
// SELECT * FROM orders WHERE user_id IN (1,2) AND state NOT IN ('cancelled');
&lt;/code>&lt;/pre>
&lt;p>第一个是在查找Order时添加约束，第二个是在查找User时添加where，然后查找Order时添加约束&lt;/p>
&lt;p>&lt;strong>2、嵌套预加载&lt;/strong>&lt;/p>
&lt;p>假设Order里又包含has one关系，对应一个产品，查User时能把Orders.Product查出来吗？&lt;/p>
&lt;pre>&lt;code>type User struct {
gorm.Model
Username string
Orders []Order
City City
}
type Order struct {
gorm.Model
UserID uint
Price float64
ProductID uint
Product Product
}
type Product struct {
gorm.Model
Name string
Price float64
}
&lt;/code>&lt;/pre>
&lt;p>是可以的，但是要用嵌套预加载，指定加载&lt;code>Orders.Product&lt;/code>&lt;/p>
&lt;pre>&lt;code>db.Preload(&amp;quot;Orders.Product&amp;quot;).Preload(&amp;quot;City&amp;quot;).Find(&amp;amp;users)
&lt;/code>&lt;/pre>
&lt;h2 id="关联模式">关联模式&lt;/h2>
&lt;p>由于关系的存在（belongs to，has one，has many，many to many），我们可以通过关系进行CRUD。&lt;/p>
&lt;p>比如假设一个人有多张卡，User和CreditCard是一对多关系，想给User添加一张新的卡，一个方法是直接操作CreditCard表，设置卡属性、UserID，再保存。&lt;/p>
&lt;p>另一个方法是通过User和CreditCard的一对多关系操作，给User Append一张卡：&lt;/p>
&lt;pre>&lt;code>db.Model(&amp;amp;user).Association(&amp;quot;CreditCard&amp;quot;).Append(&amp;amp;CreditCard{Number: &amp;quot;411111111111&amp;quot;})
&lt;/code>&lt;/pre>
&lt;p>上述代码指明了User是谁（&amp;amp;user，源模型，主键不能为空），指明哪个关系（CreditCard，结构字段名），操作是什么（append+卡信息），注意此处卡不需要声明UserID，因为这个关系已经给出了。&lt;/p>
&lt;p>这是通过关联模式的添加功能。我们可以通过关系实现完整的CRUD。&lt;/p>
&lt;p>// to be continuing&lt;/p></description></item><item><title>一个Golang RSS内容匹配器</title><link>https://chajiuqqq.github.io/blogs/p/%E4%B8%80%E4%B8%AAgolang-rss%E5%86%85%E5%AE%B9%E5%8C%B9%E9%85%8D%E5%99%A8/</link><pubDate>Tue, 07 Feb 2023 12:01:09 +0800</pubDate><guid>https://chajiuqqq.github.io/blogs/p/%E4%B8%80%E4%B8%AAgolang-rss%E5%86%85%E5%AE%B9%E5%8C%B9%E9%85%8D%E5%99%A8/</guid><description>&lt;blockquote>
&lt;p>go-in-action里的一个demo，给定需要匹配的字符串，在搜索源（如rss）中批量查询最新文章，返回结果（如相匹配的title和description）&lt;/p>
&lt;p>关键字：&lt;code>goroutine并发&lt;/code>，&lt;code>json/xml反序列化&lt;/code>，&lt;code>网络请求&lt;/code>&lt;/p>
&lt;p>项目地址：https://github.com/chajiuqqq/go-rss-matcher&lt;/p>
&lt;/blockquote>
&lt;p>效果：搜索“China”，发现了近期和China相关的文章，如中国气球误入美国:&lt;/p>
&lt;pre>&lt;code>$ ./rss-matcher
2023/02/04 12:04:33 title
China says balloon spotted over U.S. is a 'civilian airship' that blew astray
2023/02/04 12:04:33 description
The State Department announced Secretary of State Antony Blinken will not go ahead with a planned trip to China, after the surveillance balloon was detected over U.S. airspace Thursday.
2023/02/04 12:04:33 title
Tensions continue to increase between the United States and China
2023/02/04 12:04:34 HTTP Response Error: http://www.npr.org/rss/rss.php?id=43 code 404
2023/02/04 12:04:34 HTTP Response Error: http://www.npr.org/rss/rss.php?id=1021 code 404
2023/02/04 12:04:34 title
Perspective: Jiang Zemin's passing marks the end of an era for China
2023/02/04 12:04:34 description
As China holds a memorial service for its late leader Jiang Zemin, an NPR correspondent who met Jiang reflects on the figure and his transforming country.
2023/02/04 12:04:34 title
Blinken postpones China trip after discovery of surveillance balloon
2023/02/04 12:04:34 description
Secretary of State Antony Blinken has postponed his trip to China after the discovery of what the Pentagon alleges to be a Chinese surveillance balloon. China's government says it's a weather balloon.
2023/02/04 12:04:34 title
China says balloon spotted over U.S. is a 'civilian airship' that blew astray
2023/02/04 12:04:34 description
The State Department announced Secretary of State Antony Blinken will not go ahead with a planned trip to China, after the surveillance balloon was detected over U.S. airspace Thursday.
2023/02/04 12:04:34 description
China's foreign ministry described the balloon as &amp;quot;a civilian airship&amp;quot; for meteorological research that had blown far off course by winds. The Pentagon suspects it's collecting sensitive information.
&lt;/code>&lt;/pre>
&lt;p>项目结构设计上支持多种搜索源，如rss等，只要设计对应的matcher就可以进行搜索匹配。&lt;/p>
&lt;p>程序流程如下：&lt;/p>
&lt;ol>
&lt;li>读取data.json里的搜索源（feeds），并反序列化为对象供后面访问&lt;/li>
&lt;li>给每个feed寻找已注册的matcher匹配器，并开启goroutine匹配。匹配结果写入通道。
&lt;ol>
&lt;li>匹配过程首先请求feed的URL，获得XML&lt;/li>
&lt;li>解析xml，反序列化到对象&lt;/li>
&lt;li>对对象里的字段进行匹配&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>循环读取通道内的结果，并打印&lt;/li>
&lt;li>如果匹配结束，关闭通道，主程序结束&lt;/li>
&lt;/ol>
&lt;p>几个设计上的亮点：&lt;/p>
&lt;ul>
&lt;li>设计Matcher接口，所有的matcher都可以调用Search进行搜索&lt;/li>
&lt;li>设计matcherMap，不同类型的Matcher注册后保存在这里，方便不同数据源匹配和数据源类型拓展&lt;/li>
&lt;li>每个goroutine执行一个feed的搜索，并发执行，提高性能&lt;/li>
&lt;li>查询结果后，goroutine通过无缓冲chan把数据发送主线程展示，同步获取并展示，利用了语言特性&lt;/li>
&lt;/ul></description></item><item><title>一个golang自定义日志记录器</title><link>https://chajiuqqq.github.io/blogs/p/%E4%B8%80%E4%B8%AAgolang%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E5%99%A8/</link><pubDate>Tue, 07 Feb 2023 11:03:38 +0800</pubDate><guid>https://chajiuqqq.github.io/blogs/p/%E4%B8%80%E4%B8%AAgolang%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E5%99%A8/</guid><description>&lt;p>标准库的log包无法实现日志分级处理，这个demo可以实现日志的多级处理。原理是定义多个log对象，并指定不同的输出，实现不同等级日志不同输出。&lt;/p>
&lt;p>mlog包代码如下：&lt;/p>
&lt;pre>&lt;code>// mlog.go
package mlog
import (
&amp;quot;io&amp;quot;
&amp;quot;log&amp;quot;
&amp;quot;os&amp;quot;
)
var (
Trace *log.Logger
Info *log.Logger
Warning *log.Logger
Error *log.Logger
)
func init() {
file, err := os.OpenFile(&amp;quot;error.txt&amp;quot;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
if err != nil {
log.Fatalln(&amp;quot;Fail to open error file:&amp;quot;, err)
}
Trace = log.New(io.Discard, &amp;quot;TRACE: &amp;quot;, log.Ldate|log.Ltime|log.Lshortfile)
Info = log.New(os.Stdout, &amp;quot;INFO: &amp;quot;, log.Ldate|log.Ltime|log.Lshortfile)
Warning = log.New(os.Stdout, &amp;quot;WARNING: &amp;quot;, log.Ldate|log.Ltime|log.Lshortfile)
Error = log.New(file, &amp;quot;ERROR: &amp;quot;, log.Ldate|log.Ltime|log.Lshortfile)
}
&lt;/code>&lt;/pre>
&lt;p>调用测试：&lt;/p>
&lt;pre>&lt;code>package main
import &amp;quot;github.com/chajiu/go-example/mlog&amp;quot;
func main() {
mlog.Trace.Println(&amp;quot;trace...&amp;quot;)
mlog.Info.Println(&amp;quot;Info...&amp;quot;)
mlog.Warning.Println(&amp;quot;warning...&amp;quot;)
mlog.Error.Println(&amp;quot;error...&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>error.txt会在main目录下生成。&lt;/p>
&lt;pre>&lt;code>ERROR: 2023/02/07 10:56:13 main.go:9: error...
ERROR: 2023/02/07 10:56:23 main.go:9: error...
&lt;/code>&lt;/pre>
&lt;p>Info和Warning则是直接输出到stdout：&lt;/p>
&lt;pre>&lt;code>INFO: 2023/02/07 10:56:23 main.go:7: Info...
WARNING: 2023/02/07 10:56:23 main.go:8: warning...
&lt;/code>&lt;/pre></description></item><item><title>GoLang中的Strings, bytes, runes和characters</title><link>https://chajiuqqq.github.io/blogs/p/golang%E4%B8%AD%E7%9A%84strings-bytes-runes%E5%92%8Ccharacters/</link><pubDate>Fri, 07 Oct 2022 12:16:11 +0800</pubDate><guid>https://chajiuqqq.github.io/blogs/p/golang%E4%B8%AD%E7%9A%84strings-bytes-runes%E5%92%8Ccharacters/</guid><description>&lt;blockquote>
&lt;p>原文标题：Strings, bytes, runes and characters in Go&lt;/p>
&lt;p>原文地址：https://go.dev/blog/strings&lt;/p>
&lt;p>译者：z&lt;/p>
&lt;/blockquote>
&lt;h1 id="介绍">介绍&lt;/h1>
&lt;p>&lt;a class="link" href="https://blog.golang.org/slices" target="_blank" rel="noopener"
>前文&lt;/a>介绍了slice如何工作，用一些例子展示了背后实现原理。基于那样的背景下，这篇文章将讨论Go中的strings——字符串。一开始你可能觉得对于一个blog的主题来说字符串太过于简单，但是想要很好地使用它们不仅需要理解它们的工作原理，也要明白byte、character、rune间的区别，unicode和UTF-的区别，字符串和字符串字面值的区别，可能还有其他更细微之处的区别。&lt;/p>
&lt;p>开始这个主题的一个方法是思考这么一个经常被提及的问题：“当我在Go中获取字符串在n位置的东西时，为什么我没有获取到第n个字符？”，正如你所见，这个问题可以让我们思考关于字符串如何工作的更多细节问题。&lt;/p>
&lt;p>一个很棒的，不局限于Go语言的回答是Joel Spolsky的著名blog： &lt;a class="link" href="http://www.joelonsoftware.com/articles/Unicode.html" target="_blank" rel="noopener"
>The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&lt;/a>。这篇文章会重述他的一些观点。&lt;/p>
&lt;h1 id="什么是字符串">什么是字符串&lt;/h1>
&lt;p>让我们从基础开始吧。&lt;/p>
&lt;p>Go中，一个字符串实际上只是只读的byte slice而已。如果你完全不理解什么是byte的slice或者其工作原理，请读之前这篇&lt;a class="link" href="https://blog.golang.org/slices" target="_blank" rel="noopener"
>blog&lt;/a>。这里我们默认你已经读过了。&lt;/p>
&lt;p>首先要声明的很重要的一点是，字符串可以包括任意个数的字节。不一定要包含unicode格式文本、UTF-8格式文本、或其他预定义格式的文本。如果只考虑字符串的内容，它其实就是等同于byte slice。&lt;/p>
&lt;p>这是一个字符串字面值（后面会有更多），它使用&lt;code>\xNN&lt;/code>符号定义一个字符串常量，它会包含各种奇怪的byte（当然，byte范围是从16进制的00到FF，不包括FF）&lt;/p>
&lt;pre>&lt;code>const sample = &amp;quot;\xbd\xb2\x3d\xbc\x20\xe2\x8c\x98&amp;quot;
&lt;/code>&lt;/pre>
&lt;h1 id="打印字符串">打印字符串&lt;/h1>
&lt;p>由于举例的字符串中的一些字节是非ASCII字符，甚至不是UTF-8，直接打印字符串会产生不好看的输出，打印语句如下：&lt;/p>
&lt;pre>&lt;code>fmt.Println(sample)
&lt;/code>&lt;/pre>
&lt;p>会产生这样一堆东西（环境不同显示的东西也不同）&lt;/p>
&lt;pre>&lt;code>��=� ⌘
&lt;/code>&lt;/pre>
&lt;p>为了找出字符串到底包含什么，我们需要把它分开，并单独检验每一块。有一些方法可以做到，最明显的就是遍历他的内容，并把每个字节单独输出，看这个for循环：&lt;/p>
&lt;pre>&lt;code>for i := 0; i &amp;lt; len(sample); i++ {
fmt.Printf(&amp;quot;%x &amp;quot;, sample[i])
}
&lt;/code>&lt;/pre>
&lt;p>如上面展示的，通过索引可以获取到字符串的每个字节，而不是字符。下面我们再细致的看看循环输出的字节：&lt;/p>
&lt;pre>&lt;code>bd b2 3d bc 20 e2 8c 98
&lt;/code>&lt;/pre>
&lt;p>注意一下每个字节是如何和与字符串中定义的16进制值对应的。&lt;/p>
&lt;p>一个更短的产生可观输出的方法是使用fmt的&lt;code>%X&lt;/code>（16进制）格式。它会以16进制输出字符串的字节序列，每个字节是两位：&lt;/p>
&lt;pre>&lt;code>fmt.Printf(&amp;quot;%x\n&amp;quot;, sample)
&lt;/code>&lt;/pre>
&lt;p>它的输出是：&lt;/p>
&lt;pre>&lt;code>bdb23dbc20e28c98
&lt;/code>&lt;/pre>
&lt;p>一个小技巧是在%和x中间添加空格，比较一下区别：&lt;/p>
&lt;pre>&lt;code>fmt.Printf(&amp;quot;% x\n&amp;quot;, sample)
&lt;/code>&lt;/pre>
&lt;p>注意下字节间如何打印空格的：&lt;/p>
&lt;pre>&lt;code>bd b2 3d bc 20 e2 8c 98
&lt;/code>&lt;/pre>
&lt;p>使用&lt;code>%q&lt;/code>可以转义输出无法显示的字节，这样输出就会很清晰：&lt;/p>
&lt;pre>&lt;code>fmt.Printf(&amp;quot;%q\n&amp;quot;, sample)
&lt;/code>&lt;/pre>
&lt;p>当大多数字符串都很正常而有一些包含了特殊符号需要剔除时，这个方法很方便，它会产生：&lt;/p>
&lt;pre>&lt;code>&amp;quot;\xbd\xb2=\xbc ⌘&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>如果我们仔细看它，会发现在乱码中有一个ASCII的等号，还有一个正常的空格，最后有个很著名的“Place of Interest” 符号。这个符号的unicode编码是U+2318，在空格（16进制值是20）后面用UTF-8编码：e2 8c 98.&lt;/p>
&lt;p>如果我们不熟悉或被字符串中的奇怪东西绕晕了，我们可以使用+号结合&lt;code>%q&lt;/code>。这个组合会输出不可打印的字符的转义格式，以及非ASCII字符的转义格式，这些格式都是UTF-8的. 非ASCII数据会以合适的UTF-8编码打印出来：&lt;/p>
&lt;pre>&lt;code>fmt.Printf(&amp;quot;%+q\n&amp;quot;, sample)
&lt;/code>&lt;/pre>
&lt;p>这种格式下，unicode格式的“Place of Interest” 符号会被展示为带&lt;code>\u&lt;/code>转义序列：&lt;/p>
&lt;pre>&lt;code>&amp;quot;\xbd\xb2=\xbc \u2318&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>这种打印的方法非常适合字符串内容的debug，下面讨论的时候也会很方便。值得一提的是，所有这些方法应用在字节slice或字符串中时表现一致。&lt;/p>
&lt;p>这是我们提及的所有打印方法，你可以在浏览器中试试运行：&lt;/p>
&lt;pre>&lt;code>package main
import &amp;quot;fmt&amp;quot;
func main() {
const sample = &amp;quot;\xbd\xb2\x3d\xbc\x20\xe2\x8c\x98&amp;quot;
fmt.Println(&amp;quot;Println:&amp;quot;)
fmt.Println(sample)
fmt.Println(&amp;quot;Byte loop:&amp;quot;)
for i := 0; i &amp;lt; len(sample); i++ {
fmt.Printf(&amp;quot;%x &amp;quot;, sample[i])
}
fmt.Printf(&amp;quot;\n&amp;quot;)
fmt.Println(&amp;quot;Printf with %x:&amp;quot;)
fmt.Printf(&amp;quot;%x\n&amp;quot;, sample)
fmt.Println(&amp;quot;Printf with % x:&amp;quot;)
fmt.Printf(&amp;quot;% x\n&amp;quot;, sample)
fmt.Println(&amp;quot;Printf with %q:&amp;quot;)
fmt.Printf(&amp;quot;%q\n&amp;quot;, sample)
fmt.Println(&amp;quot;Printf with %+q:&amp;quot;)
fmt.Printf(&amp;quot;%+q\n&amp;quot;, sample)
}
&lt;/code>&lt;/pre>
&lt;h1 id="utf-8和字符串字面值">UTF-8和字符串字面值&lt;/h1>
&lt;p>如我们所见，索引一个字符串会获得它的字节，而不是字符，一个字符串只是一串的字节而已。这意味着当我们在字符串中存储一个字符时，我们同时存了它的字节表示。让我们看一个更细致的例子：&lt;/p>
&lt;p>这是一个小程序，它按照三种不同的方式打印了只有一个字符的字符串，一种按照字符串打印，一种只打印ASCII字符，一种按照16进制打印每一个字节。为了避免混淆，我们创建了一个原始字符串，由反引号围起来，这样它就只能包含字面值（如果是普通的字符串，由于被双引号包围，可能会包含上面提到的转义序列）&lt;/p>
&lt;pre>&lt;code>func main() {
const placeOfInterest = `⌘`
fmt.Printf(&amp;quot;plain string: &amp;quot;)
fmt.Printf(&amp;quot;%s&amp;quot;, placeOfInterest)
fmt.Printf(&amp;quot;\n&amp;quot;)
fmt.Printf(&amp;quot;quoted string: &amp;quot;)
fmt.Printf(&amp;quot;%+q&amp;quot;, placeOfInterest)
fmt.Printf(&amp;quot;\n&amp;quot;)
fmt.Printf(&amp;quot;hex bytes: &amp;quot;)
for i := 0; i &amp;lt; len(placeOfInterest); i++ {
fmt.Printf(&amp;quot;%x &amp;quot;, placeOfInterest[i])
}
fmt.Printf(&amp;quot;\n&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>输出是：&lt;/p>
&lt;pre>&lt;code>plain string: ⌘
quoted string: &amp;quot;\u2318&amp;quot;
hex bytes: e2 8c 98
&lt;/code>&lt;/pre>
&lt;p>这提醒了我们U+2318是“Place of Interest” 符号 ⌘的unicode编号，并且由字节表示为e2 8c 98，这些字节是16进制数2318按照UTF-8编码后的字节表示。&lt;/p>
&lt;p>依赖于你对UTF-8的熟悉程度，你可能很清楚这些或者有点模糊，但是花点时间解释一下UTF-8是如何表示我们创建的字符串是很有必要的。最简单的事实是：当源码写入时，它就创建出来了。&lt;/p>
&lt;p>源码在Go中被定义为UTF-8文本，并且不允许其他格式的表示。这意味着在源码中，当我们输入：
&lt;code>⌘&lt;/code>
时，文本编辑器会把&lt;code>⌘&lt;/code>符号的UTF-8编码存入源码中，当我们输出16进制字节时，我们只是复制输出了文件中编辑器放入的数据。&lt;/p>
&lt;p>更精简点来说，Go语言源码是UTF-8，所以字符串字面量的源码就是UTF-8文本。如果字符串字面值不包含转义序列（反引号构建的原始字符串不能包含转义字符），构造出来的字符串引号中间的文本就是源码文本。因此原始字符串总是会包含合法的UTF-8文本。类似的，普通字符串经常由合法的UTF-8文本组成，除非它包含上面提到的不在UTF-8编码中的转义序列。&lt;/p>
&lt;blockquote>
&lt;p>译注：&lt;/p>
&lt;p>反引号 `` 组成的字符串不会进行转义处理，所以字符串内容=存入的源码&lt;/p>
&lt;p>普通字符串 &amp;quot;&amp;quot; 会进行转义处理，比如&lt;code>\x2b&lt;/code>会识别成一个16进制数据存入，而不是存入\、x、2、b。如果这个16进制数不在UTF-8编码中，那就是非法的UTF-8编码，无法被打印出来。&lt;/p>
&lt;/blockquote>
&lt;p>一些人认为Go字符串总是UTF-8编码，其实不是：只有字符串字面值是UTF-8编码.正如我们上面提到的，字符串值可以包含任意的字节；字符串字面值只要没有字节等级的转义就总是UTF-8文本。&lt;/p>
&lt;p>总结来说，字符串可以包含任意字节，但是从字面值构建时，这些字节通常都是UTF-8编码的。&lt;/p>
&lt;h1 id="code-points字符runes">Code points、字符、runes&lt;/h1>
&lt;p>目前为止我们都很小心地使用单词“字节”和“字符”。一部分原因是因为字符串包含字节，另一部分是因为字符这个概念有点难以定义。Unicode标准使用“Code point”定义单一值表示的东西，比如Code points U+2318，16进制值2318，代表了⌘符号（更多Code point参考&lt;a class="link" href="http://unicode.org/cldr/utility/character.jsp?a=2318" target="_blank" rel="noopener"
>Unicode page&lt;/a>）&lt;/p>
&lt;p>一个更普通地例子是Unicode Code point U+0061是小写字母：a&lt;/p>
&lt;p>但是小写重音字母à如何表示？这是一个字符，也是Code point U+00E0，但是它有其他表示方法。比如我们可以结合重音Code point，U+0300，附加到小写字母a，U+0061上，构建出同样的字符à。通常来说一个字符可以被多种不同的Code point组合表示，因此有不同的UTF-8字节序列。&lt;/p>
&lt;p>因此计算机的字符概念是模糊的，或者容易混淆，所以我们要小心使用。为了让他更可靠，有一些标准化技术可以保证一个字符只有一种Code point的表示方式，但是这个主题不在我们讨论的范围内，之后会有一个新的blog介绍Go库是如何处理标准化的。&lt;/p>
&lt;p>“Code point”有点绕口，为此在Go中有个更短的术语：rune。这个术语会在库和源码中出现，和Code point意思相同，但有一个新的特点。&lt;/p>
&lt;p>Go语言中rune是类型int32的别名，所以程序可以理解一个int类型的数值表示为Code point的状况。除此以外，一个字符常量在Go中其实被称为一个rune常量。&lt;/p>
&lt;pre>&lt;code>'⌘'
&lt;/code>&lt;/pre>
&lt;p>这个符号的类型是rune，值是整型的0x2318.&lt;/p>
&lt;p>总的来说，这是几个重点：&lt;/p>
&lt;ul>
&lt;li>Go源码总是UTF-8的&lt;/li>
&lt;li>一个字符串可以包含任意字节&lt;/li>
&lt;li>一个字符串字面值如果没有字节层面的转义，那就是合法的UTF-8序列。&lt;/li>
&lt;li>这些序列代表了unicode的Code point，也就是rune。&lt;/li>
&lt;li>无法保证Go中字符串的字符是标准化过的。&lt;/li>
&lt;/ul>
&lt;h1 id="for-range循环">&lt;code>for range&lt;/code>循环&lt;/h1>
&lt;p>除了不言自明的一个细节——go源码是UTF-8编码的，只有在一种情况下，go会特殊处理UTF-8编码，那就是当你对字符串使用&lt;code>for range&lt;/code>循环的时候。&lt;/p>
&lt;p>我们知道普通的&lt;code>for&lt;/code>循环会发生什么，对于&lt;code>for range&lt;/code>循环，每次遍历时都会解码一个UTF-8的rune。每次循环时，下标是当前rune的开始位置，测量单位是字节，code point就是他的值。这个例子使用了另一个打印格式&lt;code>%#U&lt;/code>，可以打印unicode编码和代表的字符：&lt;/p>
&lt;pre>&lt;code>const nihongo = &amp;quot;日本語&amp;quot;
for index, runeValue := range nihongo {
fmt.Printf(&amp;quot;%#U starts at byte position %d\n&amp;quot;, runeValue, index)
}
&lt;/code>&lt;/pre>
&lt;p>输出会显示每个code point占据了多个字节：&lt;/p>
&lt;pre>&lt;code>U+65E5 '日' starts at byte position 0
U+672C '本' starts at byte position 3
U+8A9E '語' starts at byte position 6
&lt;/code>&lt;/pre>
&lt;h1 id="标准库">标准库&lt;/h1>
&lt;p>Go的标准库对解释UTF-8文本提供了强大支持。如果&lt;code>for range&lt;/code>循环对你来说不够用，那么可以试试库里的包。&lt;/p>
&lt;p>最重要的包是&lt;code>unicode/utf8&lt;/code>，提供了UTF-8字符串的验证、拆分、组装方法。这个程序等同于上面的&lt;code>for range&lt;/code>循环，但是使用了&lt;code>DecodeRuneInString&lt;/code>方法实现。返回值是rune和他的UTF-8编码字节个数。&lt;/p>
&lt;pre>&lt;code>const nihongo = &amp;quot;日本語&amp;quot;
for i, w := 0, 0; i &amp;lt; len(nihongo); i += w {
runeValue, width := utf8.DecodeRuneInString(nihongo[i:])
fmt.Printf(&amp;quot;%#U starts at byte position %d\n&amp;quot;, runeValue, i)
w = width
}
&lt;/code>&lt;/pre>
&lt;p>运行可以看到结果相同。&lt;code>for range&lt;/code>循环和&lt;code>DecodeRuneInString &lt;/code>方法会产生相同的迭代结果。&lt;/p>
&lt;p>这个包的其他方法请查看&lt;a class="link" href="https://go.dev/pkg/unicode/utf8/" target="_blank" rel="noopener"
>unicode/utf8文档&lt;/a>&lt;/p>
&lt;h1 id="结论">结论&lt;/h1>
&lt;p>回答一下文章开始提出的问题：字符串由字节组成，因此索引字符串会获得字节，而不是字符。一个字符串甚至可能不包含字符。实际上“字符”的定义就是模糊的，如果你把字符串定义为由字符组成，你可能会遇到一些模糊性问题。&lt;/p>
&lt;p>还有很多关于unicode，UTF-8和多语言文本处理的东西可以讲，但是请等下一个blog吧，现在我希望你更理解Go的字符串如何呈现的了，即使它们可能包含任意的字节，它的核心设计的一部分仍旧是UTF-8编码.&lt;/p></description></item></channel></rss>