<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on 茶酒的小站</title><link>https://chajiuqqq.github.io/blogs/categories/golang/</link><description>Recent content in golang on 茶酒的小站</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 15 Feb 2023 11:31:41 +0800</lastBuildDate><atom:link href="https://chajiuqqq.github.io/blogs/categories/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang中的应用测试</title><link>https://chajiuqqq.github.io/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/</link><pubDate>Wed, 15 Feb 2023 11:31:41 +0800</pubDate><guid>https://chajiuqqq.github.io/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/</guid><description>&lt;p>本文记录了一下内容：&lt;/p>
&lt;ul>
&lt;li>golang的单元测试、基准测试、http测试&lt;/li>
&lt;li>测试替身和依赖注入&lt;/li>
&lt;li>第三方Go测试库，gocheck，ginkgo&lt;/li>
&lt;/ul>
&lt;p>目录：&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="#go%e5%ba%94%e7%94%a8%e6%b5%8b%e8%af%95%e6%a6%82%e8%bf%b0" >go应用测试概述&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95" >单元测试&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#%e8%b7%b3%e8%bf%87%e6%b5%8b%e8%af%95%e7%94%a8%e4%be%8b" >跳过测试用例&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#%e8%ae%be%e7%bd%ae%e5%b9%b6%e8%a1%8c%e8%bf%90%e8%a1%8c%e7%9a%84%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95%e6%95%b0%e9%87%8f" >设置并行运行的单元测试数量&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="#%e5%9f%ba%e5%87%86%e6%b5%8b%e8%af%95" >基准测试&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#%e5%a6%82%e4%bd%95%e6%b5%8b%e8%af%95http" >如何测试http&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%87%bd%e6%95%b0%e6%88%91%e8%87%aa%e5%b7%b1%e5%8f%96%e7%9a%84%e5%90%8d%e5%ad%97" >生命周期函数（我自己取的名字）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="#%e6%b5%8b%e8%af%95%e6%9b%bf%e8%ba%ab%e5%92%8c%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5" >测试替身和依赖注入&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#%e7%ac%ac%e4%b8%89%e6%96%b9go%e6%a3%80%e6%b5%8b%e5%ba%93" >第三方go检测库&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#gocheck" >gocheck&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#ginkgo" >ginkgo&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="go应用测试概述">go应用测试概述&lt;/h1>
&lt;p>go的testing包用于测试，net/http/httptest用于测试web程序。对于源码文件server.go，可以在同目录下创建server_test.go文件，定义func TestXxx(*testing.T)函数。函数内部使用Error、Fail等方法表示测试失败，如果测试时没有出现任何失败，则表示测试通过。&lt;/p>
&lt;p>编写完测试文件后，在当前目录下用&lt;code>go test&lt;/code>测试所有测试文件。&lt;/p>
&lt;h2 id="单元测试">单元测试&lt;/h2>
&lt;p>如果一个部分能独立进行测试，那被称为“单元”。向单元输入数据，并检查输出是否符合预期就是单元测试。&lt;/p>
&lt;p>testing.T中的有用的方法：&lt;/p>
&lt;ul>
&lt;li>Log，Logf：把文本记录到错误日志中，不终止测试&lt;/li>
&lt;li>Fail：标记当前测试单元“失败”&lt;/li>
&lt;li>FailNow：标记当前测试函数“失败”，并终止当前测试单元&lt;/li>
&lt;/ul>
&lt;p>Error,Errorf,Fatal,Fatalf是上述函数的复合，见下表。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">&lt;/th>
&lt;th style="text-align:left">Log&lt;/th>
&lt;th style="text-align:left">Logf&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">Fail&lt;/td>
&lt;td style="text-align:left">Error&lt;/td>
&lt;td style="text-align:left">Errorf&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">FailNow&lt;/td>
&lt;td style="text-align:left">Fatal&lt;/td>
&lt;td style="text-align:left">Fatalf&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>这些方法只对当前单元有效。&lt;/p>
&lt;p>单元测试中的命令：&lt;/p>
&lt;ul>
&lt;li>&lt;code>-v&lt;/code>获取详细测试信息&lt;/li>
&lt;li>&lt;code>-cover&lt;/code>输出代码覆盖率&lt;/li>
&lt;/ul>
&lt;p>如&lt;code>go test -v -cover&lt;/code>&lt;/p>
&lt;h3 id="跳过测试用例">跳过测试用例&lt;/h3>
&lt;p>如果在单元测试中调用&lt;code>t.Skip()&lt;/code>函数，则会在执行到这一行时跳过该测试单元的其余部分。&lt;/p>
&lt;p>命令中也提供这么个flag，用于逻辑判断：&lt;code>-short&lt;/code>，当设置了&lt;code>-short&lt;/code>时（如&lt;code>go test -v -cover -short&lt;/code>），代码中调用testing.Short()返回true.&lt;/p>
&lt;p>将&lt;code>-short&lt;/code>和&lt;code>t.Skip()&lt;/code>结合使用，可实现命令行控制是否跳过某些测试函数，如：&lt;/p>
&lt;pre>&lt;code>func TestXxxx(t *testing.T){
if testing.Short(){
t.Skip(&amp;quot;skip for short flag.&amp;quot;)
}
...
}
&lt;/code>&lt;/pre>
&lt;h3 id="设置并行运行的单元测试数量">设置并行运行的单元测试数量&lt;/h3>
&lt;p>利用&lt;code>-parallel n&lt;/code>设置并行运行的单元测试数量。如&lt;code>go test -v -parallel 3&lt;/code>表示最多并行运行3个单元测试。&lt;/p>
&lt;h2 id="基准测试">基准测试&lt;/h2>
&lt;p>利用&lt;code>-bench [函数名的正则表达式]&lt;/code>flag，执行*_test.go中定义的基准函数的测试，用于评估函数的性能。基准函数格式：&lt;/p>
&lt;pre>&lt;code>func BenchmarkXxx(*testing.B){...}
&lt;/code>&lt;/pre>
&lt;p>通常在其中添加循环，执行&lt;code>b.N&lt;/code>次程序，以此观察程序性能：&lt;/p>
&lt;pre>&lt;code>func BenchmarkXxx(b *testing.B){
for i:=0;i&amp;lt;b.N;i++{
...
}
}
&lt;/code>&lt;/pre>
&lt;p>执行所有单元测试和基准函数：&lt;code>go test -v -bench .&lt;/code>&lt;/p>
&lt;p>如要忽略单元测试，使用&lt;code>-run [函数名的正则表达式]&lt;/code>来指定要运行的单元测试。设置为&lt;code>-run none&lt;/code>则会忽略所有单元测试。结合一下，&lt;code>go test -v -run none -bench .&lt;/code>就只会执行基准测试了。&lt;/p>
&lt;h2 id="如何测试http">如何测试http&lt;/h2>
&lt;p>测试http就是在测试处理器函数，这种函数接受http.ResponseWriter和*http.Request.问题在于如何提供这两个参数。我们可以在测试函数中伪造http server、http请求，并把response记录下来，实现伪造http整个流程，从而实现测试。&lt;/p>
&lt;p>下面代码实现了对处理器函数的测试：&lt;/p>
&lt;ol>
&lt;li>伪造一个http server&lt;/li>
&lt;li>指定要测试的处理器函数和路径&lt;/li>
&lt;li>伪造GET请求&lt;/li>
&lt;li>把response记录在httptest.ResponseRecorder中&lt;/li>
&lt;li>读取response，看程序是否符合预期&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>func TestHandleGet(t *testing.T) {
mux := http.NewServeMux()
mux.HandleFunc(&amp;quot;/post/&amp;quot;, handleRequest)
writer := httptest.NewRecorder()
req, _ := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;/post/1&amp;quot;, nil)
mux.ServeHTTP(writer, req)
if writer.Code != 200 {
t.Errorf(&amp;quot;response code is %d&amp;quot;, writer.Code)
}
var post data.Post
json.Unmarshal(writer.Body.Bytes(), &amp;amp;post)
if post.Id != 1 {
t.Error(&amp;quot;can't retrieve JSON post&amp;quot;)
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="生命周期函数我自己取的名字">生命周期函数（我自己取的名字）&lt;/h3>
&lt;p>为了在测试前、测试后统一执行一些共有的代码，可以利用生命周期函数实现。首先定义函数TestMain&lt;/p>
&lt;pre>&lt;code>func TestMain(m *testing.M) {
setUp()
code := m.Run()
tearDown()
os.Exit(code)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>setUp()&lt;/code>和&lt;code>tearDown()&lt;/code>都是为所有测试用例定义的函数，m.Run()会调用测试案例，所以&lt;code>setUp()&lt;/code>在测试前执行，&lt;code>tearDown()&lt;/code>在测试后执行。&lt;strong>并且在整个测试中只会执行一次。&lt;/strong>&lt;/p>
&lt;p>上述TestHandleGet方法我们也可以优化为：&lt;/p>
&lt;pre>&lt;code>var mux *http.ServeMux
var writer *httptest.ResponseRecorder
func TestMain(m *testing.M) {
setUp()
code := m.Run()
os.Exit(code)
}
func setUp() {
mux = http.NewServeMux()
mux.HandleFunc(&amp;quot;/post/&amp;quot;, handleRequest)
writer = httptest.NewRecorder()
}
func TestHandleGet(t *testing.T) {
req, _ := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;/post/1&amp;quot;, nil)
mux.ServeHTTP(writer, req)
if writer.Code != 200 {
t.Errorf(&amp;quot;response code is %d&amp;quot;, writer.Code)
}
var post data.Post
json.Unmarshal(writer.Body.Bytes(), &amp;amp;post)
if post.Id != 1 {
t.Error(&amp;quot;can't retrieve JSON post&amp;quot;)
}
}
&lt;/code>&lt;/pre>
&lt;p>这样就把mux和writer作为全局变量。测试开始前进行初始化设置。&lt;/p>
&lt;h1 id="测试替身和依赖注入">测试替身和依赖注入&lt;/h1>
&lt;p>为了不在测试中执行真实的操作，如测试邮件发送不希望真的发送邮件；测试数据库不希望真的修改数据库（某些场景下），我们需要用接口来实现依赖注入（替换实际对象），由依赖关系代替实际的操作，实现层的解耦。&lt;/p>
&lt;h1 id="第三方go检测库">第三方go检测库&lt;/h1>
&lt;h2 id="gocheck">gocheck&lt;/h2>
&lt;p>这是一个基于testing构建的测试框架。安装：&lt;code>go get gopkg.in/check.v1&lt;/code>&lt;/p>
&lt;p>有几个特点：&lt;/p>
&lt;ul>
&lt;li>以suite为单位分组测试（测试某个结构里的所有测试方法）&lt;/li>
&lt;li>suite或单个测试用例粒度的生命周期函数（测试夹具）&lt;/li>
&lt;li>。。。&lt;/li>
&lt;/ul>
&lt;p>使用例子，只有注册过的Suite才会被测试：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">import(
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> . &amp;#34;gopkg.in/check.v1&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//定义suite
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">type XxxSuite struct{}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//注册suite,只有注册过的Suite才会被测试
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">func init(){
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Suite(&amp;amp;XxxSuite{})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//定义suite里的测试方法
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">func (x *XxxSuite) TestHandleGet(c *C){
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> c.Check(code,Equals,200)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>go test -check.vv&lt;/code> 会显示更详细的日志&lt;/p>
&lt;p>测试夹具（预定义的生命周期函数）：&lt;/p>
&lt;ul>
&lt;li>suite粒度（当前套件执行前后调用）
&lt;ul>
&lt;li>SetUpSuite&lt;/li>
&lt;li>TearDownSuite&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>测试用例粒度（当前套件的每个测试用例执行前后调用）
&lt;ul>
&lt;li>SetUpTest&lt;/li>
&lt;li>TearDownTest&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>注意这几个函数需要定义在suite内，如：&lt;code>func (x *XxxSuite) SetUpSuite(c *C){}&lt;/code> &lt;code>func (x *XxxSuite) SetUpTest(c *C){}&lt;/code>&lt;/p>
&lt;h2 id="ginkgo">ginkgo&lt;/h2>
&lt;p>一个行为驱动开发（BDD）风格的Go测试框架。主要用于实现BDD，但是这里只用作测试框架使用。&lt;/p>
&lt;p>BDD，软件由目标行为定义。这些行为也就是业务需求，如：&lt;/p>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/bdd.png"
width="360"
height="288"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/bdd_hu562acb1999a1026474a0aa02db55fa8e_62212_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/bdd_hu562acb1999a1026474a0aa02db55fa8e_62212_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="125"
data-flex-basis="300px"
>&lt;/p>
&lt;p>&lt;strong>1、用ginkgo转换已存在的测试用例为BDD风格&lt;/strong>&lt;/p>
&lt;p>在包含测试文件的目录下执行&lt;code>ginkgo convert .&lt;/code>，会生成&lt;code>xxx_suite_test.go&lt;/code>（相当于原来testing的入口），并对原&lt;code>xxx_test.go&lt;/code>进行修改，因此注意备份。&lt;/p>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo1.png"
width="415"
height="295"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo1_hucd32dd84a59b21270f8fc958c69c4140_58233_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo1_hucd32dd84a59b21270f8fc958c69c4140_58233_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="140"
data-flex-basis="337px"
>&lt;/p>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo2.png"
width="593"
height="379"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo2_hu58542b68b29aee11689b241cf1f01267_101146_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo2_hu58542b68b29aee11689b241cf1f01267_101146_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="156"
data-flex-basis="375px"
>&lt;/p>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo3.png"
width="661"
height="645"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo3_hu2b74b3cdcd9234ac0a5a7164ffd9d132_170488_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo3_hu2b74b3cdcd9234ac0a5a7164ffd9d132_170488_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="102"
data-flex-basis="245px"
>&lt;/p>
&lt;p>&lt;strong>2、自己编写ginkgo用例&lt;/strong>&lt;/p>
&lt;p>用到2个命令：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ginkgo bootstrap&lt;/code>:创建引导文件（我取的名字），类似&lt;code>xxx_suite_test.go&lt;/code>&lt;/li>
&lt;li>&lt;code>ginkgo generate&lt;/code>:创建测试用例文件的骨架：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo4.png"
width="428"
height="254"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo4_hu9c5292ea206b45f2fa38342a582ec3ea_59200_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo4_hu9c5292ea206b45f2fa38342a582ec3ea_59200_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="168"
data-flex-basis="404px"
>&lt;/p>
&lt;p>这里首先再导入一个断言包Gomega，为啥要用这个呢，可能功能更强大吧。&lt;/p>
&lt;p>&lt;code>go get github.com/onsi/gomega&lt;/code>&lt;/p>
&lt;p>接下来就在这个Describe函数里描述用户故事、情景。也就是用他给定的格式写测试代码。&lt;/p>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo5.png"
width="816"
height="913"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo5_hudf13b97f83400c128b950d090612810f_267180_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo5_hudf13b97f83400c128b950d090612810f_267180_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="89"
data-flex-basis="214px"
>&lt;/p>
&lt;p>当然ginkgo的测试夹具（预定义的生命周期函数）也不可少，&lt;code>BeforeEach()&lt;/code>会在每个&lt;code>情景&lt;/code>前执行(也就是每个context函数前执行)：&lt;/p>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo6.png"
width="719"
height="199"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo6_hu17f44393d4b37e520a6c6d067c66257d_69463_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/ginkgo6_hu17f44393d4b37e520a6c6d067c66257d_69463_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="361"
data-flex-basis="867px"
>&lt;/p></description></item><item><title>Golang中的数据存储</title><link>https://chajiuqqq.github.io/blogs/p/golang%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</link><pubDate>Sun, 12 Feb 2023 08:47:06 +0800</pubDate><guid>https://chajiuqqq.github.io/blogs/p/golang%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</guid><description>&lt;p>Golang中的数据存储有三种方案：&lt;/p>
&lt;ul>
&lt;li>利用容器的内存存储（非内存数据库）&lt;/li>
&lt;li>利用文件读写的存储（文本文件如csv、二进制文件如gob）&lt;/li>
&lt;li>数据库存储&lt;/li>
&lt;/ul>
&lt;p>本文简述后面两种。&lt;/p>
&lt;h1 id="文件存储">文件存储&lt;/h1>
&lt;p>下面展示了golang中读写文件的常用方式。&lt;/p>
&lt;ul>
&lt;li>ioutil的函数读写文件&lt;/li>
&lt;li>os创建File，再读写文件&lt;/li>
&lt;/ul>
&lt;p>code:&lt;/p>
&lt;pre>&lt;code>package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;io/ioutil&amp;quot;
&amp;quot;os&amp;quot;
)
func main() {
//ioutil读写文件
data := []byte(&amp;quot;hello world!&amp;quot;)
err := ioutil.WriteFile(&amp;quot;data1&amp;quot;, data, 0644)
if err != nil {
panic(err)
}
read1, _ := ioutil.ReadFile(&amp;quot;data1&amp;quot;)
fmt.Println(string(read1))
//os读写文件
file1, _ := os.Create(&amp;quot;data2&amp;quot;)
defer file1.Close()
nbytes, _ := file1.Write(data)
fmt.Printf(&amp;quot;wrote %d bytes to file\n&amp;quot;, nbytes)
file2, _ := os.Open(&amp;quot;data2&amp;quot;)
defer file2.Close()
read2 := make([]byte, len(data))
nbytes, _ = file2.Read(read2)
fmt.Printf(&amp;quot;Read %d bytes from file\n&amp;quot;, nbytes)
fmt.Println(string(read2))
}
//
hello world!
wrote 12 bytes to file
Read 12 bytes from file
hello world!
&lt;/code>&lt;/pre>
&lt;h2 id="csv读写">csv读写&lt;/h2>
&lt;p>利用&amp;quot;encoding/csv&amp;quot;可实现csv读写，下面是小例子。将File传给csv.NewWriter()或csv.NewReader()&lt;/p>
&lt;pre>&lt;code>package main
import (
&amp;quot;encoding/csv&amp;quot;
&amp;quot;fmt&amp;quot;
&amp;quot;os&amp;quot;
&amp;quot;strconv&amp;quot;
)
type Post struct {
Id int
Content string
Author string
}
func main() {
csvFile, err := os.Create(&amp;quot;posts.csv&amp;quot;)
if err != nil {
panic(err)
}
defer csvFile.Close()
allPosts := []Post{
Post{1, &amp;quot;hello world 1&amp;quot;, &amp;quot;Jack1&amp;quot;},
Post{2, &amp;quot;hello world 2&amp;quot;, &amp;quot;Jack2&amp;quot;},
Post{3, &amp;quot;hello world 3&amp;quot;, &amp;quot;Jack3&amp;quot;},
Post{4, &amp;quot;hello world 4&amp;quot;, &amp;quot;Jack4&amp;quot;},
Post{5, &amp;quot;hello world 5&amp;quot;, &amp;quot;Jack5&amp;quot;},
}
writer := csv.NewWriter(csvFile)
for _, post := range allPosts {
line := []string{strconv.Itoa(post.Id), post.Content, post.Author}
if err := writer.Write(line); err != nil {
panic(err)
}
}
writer.Flush()
file, err := os.Open(&amp;quot;posts.csv&amp;quot;)
if err != nil {
panic(err)
}
defer file.Close()
reader := csv.NewReader(file)
reader.FieldsPerRecord = -1
records, err := reader.ReadAll()
if err != nil {
panic(err)
}
var posts []Post
for _, item := range records {
id, _ := strconv.Atoi(item[0])
post := Post{id, item[1], item[2]}
posts = append(posts, post)
}
fmt.Println(posts[0].Id)
fmt.Println(posts[0].Content)
fmt.Println(posts[0].Author)
}
&lt;/code>&lt;/pre>
&lt;p>生成posts.csv:&lt;/p>
&lt;pre>&lt;code>1,hello world 1,Jack1
2,hello world 2,Jack2
3,hello world 3,Jack3
4,hello world 4,Jack4
5,hello world 5,Jack5
&lt;/code>&lt;/pre>
&lt;h2 id="gob读写">gob读写&lt;/h2>
&lt;p>利用&amp;quot;encoding/gob&amp;quot;包，gob.NewEncoder()接受一个io.Writer; gob.NewDecoder()接受一个io.Reader.&lt;/p>
&lt;p>也就是说，可以提供一个buffer，供编码时存储结果；供解码时存储输入。&lt;/p>
&lt;p>最后传入&lt;code>&amp;amp;postRecord&lt;/code>才能修改原变量内容。&lt;/p>
&lt;pre>&lt;code>package main
import (
&amp;quot;bytes&amp;quot;
&amp;quot;encoding/gob&amp;quot;
&amp;quot;fmt&amp;quot;
&amp;quot;io/ioutil&amp;quot;
)
type Post struct {
Id int
Content string
Author string
}
func store(data interface{}, filename string) {
buffer := new(bytes.Buffer)
encoder := gob.NewEncoder(buffer)
err := encoder.Encode(data)
if err != nil {
panic(err)
}
err = ioutil.WriteFile(filename, buffer.Bytes(), 0600)
if err != nil {
panic(err)
}
}
func load(data interface{}, filename string) {
raw, err := ioutil.ReadFile(filename)
if err != nil {
panic(err)
}
buffer := bytes.NewBuffer(raw)
decoder := gob.NewDecoder(buffer)
err = decoder.Decode(data)
if err != nil {
panic(err)
}
}
func main() {
post := Post{1, &amp;quot;hello world&amp;quot;, &amp;quot;jack&amp;quot;}
store(post, &amp;quot;post1&amp;quot;)
var postRecord Post
load(&amp;amp;postRecord, &amp;quot;post1&amp;quot;)
fmt.Println(postRecord)
}
&lt;/code>&lt;/pre>
&lt;h1 id="利用databasesql连接数据库并执行crud">利用database/sql连接数据库并执行CRUD&lt;/h1>
&lt;p>首先需要注入对应的数据库驱动，如postgres常用github.com/lib/pq驱动。在main包中注入：&lt;/p>
&lt;pre>&lt;code>import(
_ &amp;quot;github.com/lib/pq&amp;quot;
)
&lt;/code>&lt;/pre>
&lt;p>数据库连接，使用sql.Open(数据库名称，数据源字符串)，其中数据源字符串需要符合对应驱动的格式，如pq的话，有这么几种合法的格式：&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;user=pqgotest dbname=pqgotest sslmode=verify-full&amp;rdquo;&lt;/li>
&lt;li>&amp;ldquo;postgres://pqgotest:password@localhost/pqgotest?sslmode=verify-full&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;p>见 &lt;a class="link" href="https://pkg.go.dev/github.com/lib/pq" target="_blank" rel="noopener"
>https://pkg.go.dev/github.com/lib/pq&lt;/a>&lt;/p>
&lt;p>CRUD总结：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>预处理语句：使用sql.Stmt结构&lt;/p>
&lt;pre>&lt;code> stmt,err := db.Prepare(&amp;quot;...&amp;quot;)
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>执行语句并获取一个sql.Row,一般后跟Scan(),用于把这一行读取到某些变量中&lt;/p>
&lt;pre>&lt;code> db.QueryRow(&amp;quot;...&amp;quot;, , )
或
stmt.QueryRow( , )
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>执行并获取多个sql.Row:&lt;/p>
&lt;pre>&lt;code> rows,err := db.Query(&amp;quot;...&amp;quot;, , )
rows.Next()
rows.Scan()
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>直接执行语句，只返回最后插入ID(如果insert)、影响的行数（insert、update、delete），不返回查询结果：&lt;/p>
&lt;pre>&lt;code> res,err := db.Exec(&amp;quot;...&amp;quot;, , )
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h1 id="go-orm-关系映射器">go orm 关系映射器&lt;/h1>
&lt;p>ORM 思想是将数据结构和表结构相对应。Gorm是go里最棒的ORM。&lt;/p></description></item><item><title>一个Golang RSS内容匹配器</title><link>https://chajiuqqq.github.io/blogs/p/%E4%B8%80%E4%B8%AAgolang-rss%E5%86%85%E5%AE%B9%E5%8C%B9%E9%85%8D%E5%99%A8/</link><pubDate>Tue, 07 Feb 2023 12:01:09 +0800</pubDate><guid>https://chajiuqqq.github.io/blogs/p/%E4%B8%80%E4%B8%AAgolang-rss%E5%86%85%E5%AE%B9%E5%8C%B9%E9%85%8D%E5%99%A8/</guid><description>&lt;blockquote>
&lt;p>go-in-action里的一个demo，给定需要匹配的字符串，在搜索源（如rss）中批量查询最新文章，返回结果（如相匹配的title和description）&lt;/p>
&lt;p>关键字：&lt;code>goroutine并发&lt;/code>，&lt;code>json/xml反序列化&lt;/code>，&lt;code>网络请求&lt;/code>&lt;/p>
&lt;p>项目地址：https://github.com/chajiuqqq/go-rss-matcher&lt;/p>
&lt;/blockquote>
&lt;p>效果：搜索“China”，发现了近期和China相关的文章，如中国气球误入美国:&lt;/p>
&lt;pre>&lt;code>$ ./rss-matcher
2023/02/04 12:04:33 title
China says balloon spotted over U.S. is a 'civilian airship' that blew astray
2023/02/04 12:04:33 description
The State Department announced Secretary of State Antony Blinken will not go ahead with a planned trip to China, after the surveillance balloon was detected over U.S. airspace Thursday.
2023/02/04 12:04:33 title
Tensions continue to increase between the United States and China
2023/02/04 12:04:34 HTTP Response Error: http://www.npr.org/rss/rss.php?id=43 code 404
2023/02/04 12:04:34 HTTP Response Error: http://www.npr.org/rss/rss.php?id=1021 code 404
2023/02/04 12:04:34 title
Perspective: Jiang Zemin's passing marks the end of an era for China
2023/02/04 12:04:34 description
As China holds a memorial service for its late leader Jiang Zemin, an NPR correspondent who met Jiang reflects on the figure and his transforming country.
2023/02/04 12:04:34 title
Blinken postpones China trip after discovery of surveillance balloon
2023/02/04 12:04:34 description
Secretary of State Antony Blinken has postponed his trip to China after the discovery of what the Pentagon alleges to be a Chinese surveillance balloon. China's government says it's a weather balloon.
2023/02/04 12:04:34 title
China says balloon spotted over U.S. is a 'civilian airship' that blew astray
2023/02/04 12:04:34 description
The State Department announced Secretary of State Antony Blinken will not go ahead with a planned trip to China, after the surveillance balloon was detected over U.S. airspace Thursday.
2023/02/04 12:04:34 description
China's foreign ministry described the balloon as &amp;quot;a civilian airship&amp;quot; for meteorological research that had blown far off course by winds. The Pentagon suspects it's collecting sensitive information.
&lt;/code>&lt;/pre>
&lt;p>项目结构设计上支持多种搜索源，如rss等，只要设计对应的matcher就可以进行搜索匹配。&lt;/p>
&lt;p>程序流程如下：&lt;/p>
&lt;ol>
&lt;li>读取data.json里的搜索源（feeds），并反序列化为对象供后面访问&lt;/li>
&lt;li>给每个feed寻找已注册的matcher匹配器，并开启goroutine匹配。匹配结果写入通道。
&lt;ol>
&lt;li>匹配过程首先请求feed的URL，获得XML&lt;/li>
&lt;li>解析xml，反序列化到对象&lt;/li>
&lt;li>对对象里的字段进行匹配&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>循环读取通道内的结果，并打印&lt;/li>
&lt;li>如果匹配结束，关闭通道，主程序结束&lt;/li>
&lt;/ol>
&lt;p>几个设计上的亮点：&lt;/p>
&lt;ul>
&lt;li>设计Matcher接口，所有的matcher都可以调用Search进行搜索&lt;/li>
&lt;li>设计matcherMap，不同类型的Matcher注册后保存在这里，方便不同数据源匹配和数据源类型拓展&lt;/li>
&lt;li>每个goroutine执行一个feed的搜索，并发执行，提高性能&lt;/li>
&lt;li>查询结果后，goroutine通过无缓冲chan把数据发送主线程展示，同步获取并展示，利用了语言特性&lt;/li>
&lt;/ul></description></item><item><title>一个golang自定义日志记录器</title><link>https://chajiuqqq.github.io/blogs/p/%E4%B8%80%E4%B8%AAgolang%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E5%99%A8/</link><pubDate>Tue, 07 Feb 2023 11:03:38 +0800</pubDate><guid>https://chajiuqqq.github.io/blogs/p/%E4%B8%80%E4%B8%AAgolang%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E5%99%A8/</guid><description>&lt;p>标准库的log包无法实现日志分级处理，这个demo可以实现日志的多级处理。原理是定义多个log对象，并指定不同的输出，实现不同等级日志不同输出。&lt;/p>
&lt;p>mlog包代码如下：&lt;/p>
&lt;pre>&lt;code>// mlog.go
package mlog
import (
&amp;quot;io&amp;quot;
&amp;quot;log&amp;quot;
&amp;quot;os&amp;quot;
)
var (
Trace *log.Logger
Info *log.Logger
Warning *log.Logger
Error *log.Logger
)
func init() {
file, err := os.OpenFile(&amp;quot;error.txt&amp;quot;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
if err != nil {
log.Fatalln(&amp;quot;Fail to open error file:&amp;quot;, err)
}
Trace = log.New(io.Discard, &amp;quot;TRACE: &amp;quot;, log.Ldate|log.Ltime|log.Lshortfile)
Info = log.New(os.Stdout, &amp;quot;INFO: &amp;quot;, log.Ldate|log.Ltime|log.Lshortfile)
Warning = log.New(os.Stdout, &amp;quot;WARNING: &amp;quot;, log.Ldate|log.Ltime|log.Lshortfile)
Error = log.New(file, &amp;quot;ERROR: &amp;quot;, log.Ldate|log.Ltime|log.Lshortfile)
}
&lt;/code>&lt;/pre>
&lt;p>调用测试：&lt;/p>
&lt;pre>&lt;code>package main
import &amp;quot;github.com/chajiu/go-example/mlog&amp;quot;
func main() {
mlog.Trace.Println(&amp;quot;trace...&amp;quot;)
mlog.Info.Println(&amp;quot;Info...&amp;quot;)
mlog.Warning.Println(&amp;quot;warning...&amp;quot;)
mlog.Error.Println(&amp;quot;error...&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>error.txt会在main目录下生成。&lt;/p>
&lt;pre>&lt;code>ERROR: 2023/02/07 10:56:13 main.go:9: error...
ERROR: 2023/02/07 10:56:23 main.go:9: error...
&lt;/code>&lt;/pre>
&lt;p>Info和Warning则是直接输出到stdout：&lt;/p>
&lt;pre>&lt;code>INFO: 2023/02/07 10:56:23 main.go:7: Info...
WARNING: 2023/02/07 10:56:23 main.go:8: warning...
&lt;/code>&lt;/pre></description></item><item><title>GoLang中的Strings, bytes, runes和characters</title><link>https://chajiuqqq.github.io/blogs/p/golang%E4%B8%AD%E7%9A%84strings-bytes-runes%E5%92%8Ccharacters/</link><pubDate>Fri, 07 Oct 2022 12:16:11 +0800</pubDate><guid>https://chajiuqqq.github.io/blogs/p/golang%E4%B8%AD%E7%9A%84strings-bytes-runes%E5%92%8Ccharacters/</guid><description>&lt;blockquote>
&lt;p>原文标题：Strings, bytes, runes and characters in Go&lt;/p>
&lt;p>原文地址：https://go.dev/blog/strings&lt;/p>
&lt;p>译者：z&lt;/p>
&lt;/blockquote>
&lt;h1 id="介绍">介绍&lt;/h1>
&lt;p>&lt;a class="link" href="https://blog.golang.org/slices" target="_blank" rel="noopener"
>前文&lt;/a>介绍了slice如何工作，用一些例子展示了背后实现原理。基于那样的背景下，这篇文章将讨论Go中的strings——字符串。一开始你可能觉得对于一个blog的主题来说字符串太过于简单，但是想要很好地使用它们不仅需要理解它们的工作原理，也要明白byte、character、rune间的区别，unicode和UTF-的区别，字符串和字符串字面值的区别，可能还有其他更细微之处的区别。&lt;/p>
&lt;p>开始这个主题的一个方法是思考这么一个经常被提及的问题：“当我在Go中获取字符串在n位置的东西时，为什么我没有获取到第n个字符？”，正如你所见，这个问题可以让我们思考关于字符串如何工作的更多细节问题。&lt;/p>
&lt;p>一个很棒的，不局限于Go语言的回答是Joel Spolsky的著名blog： &lt;a class="link" href="http://www.joelonsoftware.com/articles/Unicode.html" target="_blank" rel="noopener"
>The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&lt;/a>。这篇文章会重述他的一些观点。&lt;/p>
&lt;h1 id="什么是字符串">什么是字符串&lt;/h1>
&lt;p>让我们从基础开始吧。&lt;/p>
&lt;p>Go中，一个字符串实际上只是只读的byte slice而已。如果你完全不理解什么是byte的slice或者其工作原理，请读之前这篇&lt;a class="link" href="https://blog.golang.org/slices" target="_blank" rel="noopener"
>blog&lt;/a>。这里我们默认你已经读过了。&lt;/p>
&lt;p>首先要声明的很重要的一点是，字符串可以包括任意个数的字节。不一定要包含unicode格式文本、UTF-8格式文本、或其他预定义格式的文本。如果只考虑字符串的内容，它其实就是等同于byte slice。&lt;/p>
&lt;p>这是一个字符串字面值（后面会有更多），它使用&lt;code>\xNN&lt;/code>符号定义一个字符串常量，它会包含各种奇怪的byte（当然，byte范围是从16进制的00到FF，不包括FF）&lt;/p>
&lt;pre>&lt;code>const sample = &amp;quot;\xbd\xb2\x3d\xbc\x20\xe2\x8c\x98&amp;quot;
&lt;/code>&lt;/pre>
&lt;h1 id="打印字符串">打印字符串&lt;/h1>
&lt;p>由于举例的字符串中的一些字节是非ASCII字符，甚至不是UTF-8，直接打印字符串会产生不好看的输出，打印语句如下：&lt;/p>
&lt;pre>&lt;code>fmt.Println(sample)
&lt;/code>&lt;/pre>
&lt;p>会产生这样一堆东西（环境不同显示的东西也不同）&lt;/p>
&lt;pre>&lt;code>��=� ⌘
&lt;/code>&lt;/pre>
&lt;p>为了找出字符串到底包含什么，我们需要把它分开，并单独检验每一块。有一些方法可以做到，最明显的就是遍历他的内容，并把每个字节单独输出，看这个for循环：&lt;/p>
&lt;pre>&lt;code>for i := 0; i &amp;lt; len(sample); i++ {
fmt.Printf(&amp;quot;%x &amp;quot;, sample[i])
}
&lt;/code>&lt;/pre>
&lt;p>如上面展示的，通过索引可以获取到字符串的每个字节，而不是字符。下面我们再细致的看看循环输出的字节：&lt;/p>
&lt;pre>&lt;code>bd b2 3d bc 20 e2 8c 98
&lt;/code>&lt;/pre>
&lt;p>注意一下每个字节是如何和与字符串中定义的16进制值对应的。&lt;/p>
&lt;p>一个更短的产生可观输出的方法是使用fmt的&lt;code>%X&lt;/code>（16进制）格式。它会以16进制输出字符串的字节序列，每个字节是两位：&lt;/p>
&lt;pre>&lt;code>fmt.Printf(&amp;quot;%x\n&amp;quot;, sample)
&lt;/code>&lt;/pre>
&lt;p>它的输出是：&lt;/p>
&lt;pre>&lt;code>bdb23dbc20e28c98
&lt;/code>&lt;/pre>
&lt;p>一个小技巧是在%和x中间添加空格，比较一下区别：&lt;/p>
&lt;pre>&lt;code>fmt.Printf(&amp;quot;% x\n&amp;quot;, sample)
&lt;/code>&lt;/pre>
&lt;p>注意下字节间如何打印空格的：&lt;/p>
&lt;pre>&lt;code>bd b2 3d bc 20 e2 8c 98
&lt;/code>&lt;/pre>
&lt;p>使用&lt;code>%q&lt;/code>可以转义输出无法显示的字节，这样输出就会很清晰：&lt;/p>
&lt;pre>&lt;code>fmt.Printf(&amp;quot;%q\n&amp;quot;, sample)
&lt;/code>&lt;/pre>
&lt;p>当大多数字符串都很正常而有一些包含了特殊符号需要剔除时，这个方法很方便，它会产生：&lt;/p>
&lt;pre>&lt;code>&amp;quot;\xbd\xb2=\xbc ⌘&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>如果我们仔细看它，会发现在乱码中有一个ASCII的等号，还有一个正常的空格，最后有个很著名的“Place of Interest” 符号。这个符号的unicode编码是U+2318，在空格（16进制值是20）后面用UTF-8编码：e2 8c 98.&lt;/p>
&lt;p>如果我们不熟悉或被字符串中的奇怪东西绕晕了，我们可以使用+号结合&lt;code>%q&lt;/code>。这个组合会输出不可打印的字符的转义格式，以及非ASCII字符的转义格式，这些格式都是UTF-8的. 非ASCII数据会以合适的UTF-8编码打印出来：&lt;/p>
&lt;pre>&lt;code>fmt.Printf(&amp;quot;%+q\n&amp;quot;, sample)
&lt;/code>&lt;/pre>
&lt;p>这种格式下，unicode格式的“Place of Interest” 符号会被展示为带&lt;code>\u&lt;/code>转义序列：&lt;/p>
&lt;pre>&lt;code>&amp;quot;\xbd\xb2=\xbc \u2318&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>这种打印的方法非常适合字符串内容的debug，下面讨论的时候也会很方便。值得一提的是，所有这些方法应用在字节slice或字符串中时表现一致。&lt;/p>
&lt;p>这是我们提及的所有打印方法，你可以在浏览器中试试运行：&lt;/p>
&lt;pre>&lt;code>package main
import &amp;quot;fmt&amp;quot;
func main() {
const sample = &amp;quot;\xbd\xb2\x3d\xbc\x20\xe2\x8c\x98&amp;quot;
fmt.Println(&amp;quot;Println:&amp;quot;)
fmt.Println(sample)
fmt.Println(&amp;quot;Byte loop:&amp;quot;)
for i := 0; i &amp;lt; len(sample); i++ {
fmt.Printf(&amp;quot;%x &amp;quot;, sample[i])
}
fmt.Printf(&amp;quot;\n&amp;quot;)
fmt.Println(&amp;quot;Printf with %x:&amp;quot;)
fmt.Printf(&amp;quot;%x\n&amp;quot;, sample)
fmt.Println(&amp;quot;Printf with % x:&amp;quot;)
fmt.Printf(&amp;quot;% x\n&amp;quot;, sample)
fmt.Println(&amp;quot;Printf with %q:&amp;quot;)
fmt.Printf(&amp;quot;%q\n&amp;quot;, sample)
fmt.Println(&amp;quot;Printf with %+q:&amp;quot;)
fmt.Printf(&amp;quot;%+q\n&amp;quot;, sample)
}
&lt;/code>&lt;/pre>
&lt;h1 id="utf-8和字符串字面值">UTF-8和字符串字面值&lt;/h1>
&lt;p>如我们所见，索引一个字符串会获得它的字节，而不是字符，一个字符串只是一串的字节而已。这意味着当我们在字符串中存储一个字符时，我们同时存了它的字节表示。让我们看一个更细致的例子：&lt;/p>
&lt;p>这是一个小程序，它按照三种不同的方式打印了只有一个字符的字符串，一种按照字符串打印，一种只打印ASCII字符，一种按照16进制打印每一个字节。为了避免混淆，我们创建了一个原始字符串，由反引号围起来，这样它就只能包含字面值（如果是普通的字符串，由于被双引号包围，可能会包含上面提到的转义序列）&lt;/p>
&lt;pre>&lt;code>func main() {
const placeOfInterest = `⌘`
fmt.Printf(&amp;quot;plain string: &amp;quot;)
fmt.Printf(&amp;quot;%s&amp;quot;, placeOfInterest)
fmt.Printf(&amp;quot;\n&amp;quot;)
fmt.Printf(&amp;quot;quoted string: &amp;quot;)
fmt.Printf(&amp;quot;%+q&amp;quot;, placeOfInterest)
fmt.Printf(&amp;quot;\n&amp;quot;)
fmt.Printf(&amp;quot;hex bytes: &amp;quot;)
for i := 0; i &amp;lt; len(placeOfInterest); i++ {
fmt.Printf(&amp;quot;%x &amp;quot;, placeOfInterest[i])
}
fmt.Printf(&amp;quot;\n&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>输出是：&lt;/p>
&lt;pre>&lt;code>plain string: ⌘
quoted string: &amp;quot;\u2318&amp;quot;
hex bytes: e2 8c 98
&lt;/code>&lt;/pre>
&lt;p>这提醒了我们U+2318是“Place of Interest” 符号 ⌘的unicode编号，并且由字节表示为e2 8c 98，这些字节是16进制数2318按照UTF-8编码后的字节表示。&lt;/p>
&lt;p>依赖于你对UTF-8的熟悉程度，你可能很清楚这些或者有点模糊，但是花点时间解释一下UTF-8是如何表示我们创建的字符串是很有必要的。最简单的事实是：当源码写入时，它就创建出来了。&lt;/p>
&lt;p>源码在Go中被定义为UTF-8文本，并且不允许其他格式的表示。这意味着在源码中，当我们输入：
&lt;code>⌘&lt;/code>
时，文本编辑器会把&lt;code>⌘&lt;/code>符号的UTF-8编码存入源码中，当我们输出16进制字节时，我们只是复制输出了文件中编辑器放入的数据。&lt;/p>
&lt;p>更精简点来说，Go语言源码是UTF-8，所以字符串字面量的源码就是UTF-8文本。如果字符串字面值不包含转义序列（反引号构建的原始字符串不能包含转义字符），构造出来的字符串引号中间的文本就是源码文本。因此原始字符串总是会包含合法的UTF-8文本。类似的，普通字符串经常由合法的UTF-8文本组成，除非它包含上面提到的不在UTF-8编码中的转义序列。&lt;/p>
&lt;blockquote>
&lt;p>译注：&lt;/p>
&lt;p>反引号 `` 组成的字符串不会进行转义处理，所以字符串内容=存入的源码&lt;/p>
&lt;p>普通字符串 &amp;quot;&amp;quot; 会进行转义处理，比如&lt;code>\x2b&lt;/code>会识别成一个16进制数据存入，而不是存入\、x、2、b。如果这个16进制数不在UTF-8编码中，那就是非法的UTF-8编码，无法被打印出来。&lt;/p>
&lt;/blockquote>
&lt;p>一些人认为Go字符串总是UTF-8编码，其实不是：只有字符串字面值是UTF-8编码.正如我们上面提到的，字符串值可以包含任意的字节；字符串字面值只要没有字节等级的转义就总是UTF-8文本。&lt;/p>
&lt;p>总结来说，字符串可以包含任意字节，但是从字面值构建时，这些字节通常都是UTF-8编码的。&lt;/p>
&lt;h1 id="code-points字符runes">Code points、字符、runes&lt;/h1>
&lt;p>目前为止我们都很小心地使用单词“字节”和“字符”。一部分原因是因为字符串包含字节，另一部分是因为字符这个概念有点难以定义。Unicode标准使用“Code point”定义单一值表示的东西，比如Code points U+2318，16进制值2318，代表了⌘符号（更多Code point参考&lt;a class="link" href="http://unicode.org/cldr/utility/character.jsp?a=2318" target="_blank" rel="noopener"
>Unicode page&lt;/a>）&lt;/p>
&lt;p>一个更普通地例子是Unicode Code point U+0061是小写字母：a&lt;/p>
&lt;p>但是小写重音字母à如何表示？这是一个字符，也是Code point U+00E0，但是它有其他表示方法。比如我们可以结合重音Code point，U+0300，附加到小写字母a，U+0061上，构建出同样的字符à。通常来说一个字符可以被多种不同的Code point组合表示，因此有不同的UTF-8字节序列。&lt;/p>
&lt;p>因此计算机的字符概念是模糊的，或者容易混淆，所以我们要小心使用。为了让他更可靠，有一些标准化技术可以保证一个字符只有一种Code point的表示方式，但是这个主题不在我们讨论的范围内，之后会有一个新的blog介绍Go库是如何处理标准化的。&lt;/p>
&lt;p>“Code point”有点绕口，为此在Go中有个更短的术语：rune。这个术语会在库和源码中出现，和Code point意思相同，但有一个新的特点。&lt;/p>
&lt;p>Go语言中rune是类型int32的别名，所以程序可以理解一个int类型的数值表示为Code point的状况。除此以外，一个字符常量在Go中其实被称为一个rune常量。&lt;/p>
&lt;pre>&lt;code>'⌘'
&lt;/code>&lt;/pre>
&lt;p>这个符号的类型是rune，值是整型的0x2318.&lt;/p>
&lt;p>总的来说，这是几个重点：&lt;/p>
&lt;ul>
&lt;li>Go源码总是UTF-8的&lt;/li>
&lt;li>一个字符串可以包含任意字节&lt;/li>
&lt;li>一个字符串字面值如果没有字节层面的转义，那就是合法的UTF-8序列。&lt;/li>
&lt;li>这些序列代表了unicode的Code point，也就是rune。&lt;/li>
&lt;li>无法保证Go中字符串的字符是标准化过的。&lt;/li>
&lt;/ul>
&lt;h1 id="for-range循环">&lt;code>for range&lt;/code>循环&lt;/h1>
&lt;p>除了不言自明的一个细节——go源码是UTF-8编码的，只有在一种情况下，go会特殊处理UTF-8编码，那就是当你对字符串使用&lt;code>for range&lt;/code>循环的时候。&lt;/p>
&lt;p>我们知道普通的&lt;code>for&lt;/code>循环会发生什么，对于&lt;code>for range&lt;/code>循环，每次遍历时都会解码一个UTF-8的rune。每次循环时，下标是当前rune的开始位置，测量单位是字节，code point就是他的值。这个例子使用了另一个打印格式&lt;code>%#U&lt;/code>，可以打印unicode编码和代表的字符：&lt;/p>
&lt;pre>&lt;code>const nihongo = &amp;quot;日本語&amp;quot;
for index, runeValue := range nihongo {
fmt.Printf(&amp;quot;%#U starts at byte position %d\n&amp;quot;, runeValue, index)
}
&lt;/code>&lt;/pre>
&lt;p>输出会显示每个code point占据了多个字节：&lt;/p>
&lt;pre>&lt;code>U+65E5 '日' starts at byte position 0
U+672C '本' starts at byte position 3
U+8A9E '語' starts at byte position 6
&lt;/code>&lt;/pre>
&lt;h1 id="标准库">标准库&lt;/h1>
&lt;p>Go的标准库对解释UTF-8文本提供了强大支持。如果&lt;code>for range&lt;/code>循环对你来说不够用，那么可以试试库里的包。&lt;/p>
&lt;p>最重要的包是&lt;code>unicode/utf8&lt;/code>，提供了UTF-8字符串的验证、拆分、组装方法。这个程序等同于上面的&lt;code>for range&lt;/code>循环，但是使用了&lt;code>DecodeRuneInString&lt;/code>方法实现。返回值是rune和他的UTF-8编码字节个数。&lt;/p>
&lt;pre>&lt;code>const nihongo = &amp;quot;日本語&amp;quot;
for i, w := 0, 0; i &amp;lt; len(nihongo); i += w {
runeValue, width := utf8.DecodeRuneInString(nihongo[i:])
fmt.Printf(&amp;quot;%#U starts at byte position %d\n&amp;quot;, runeValue, i)
w = width
}
&lt;/code>&lt;/pre>
&lt;p>运行可以看到结果相同。&lt;code>for range&lt;/code>循环和&lt;code>DecodeRuneInString &lt;/code>方法会产生相同的迭代结果。&lt;/p>
&lt;p>这个包的其他方法请查看&lt;a class="link" href="https://go.dev/pkg/unicode/utf8/" target="_blank" rel="noopener"
>unicode/utf8文档&lt;/a>&lt;/p>
&lt;h1 id="结论">结论&lt;/h1>
&lt;p>回答一下文章开始提出的问题：字符串由字节组成，因此索引字符串会获得字节，而不是字符。一个字符串甚至可能不包含字符。实际上“字符”的定义就是模糊的，如果你把字符串定义为由字符组成，你可能会遇到一些模糊性问题。&lt;/p>
&lt;p>还有很多关于unicode，UTF-8和多语言文本处理的东西可以讲，但是请等下一个blog吧，现在我希望你更理解Go的字符串如何呈现的了，即使它们可能包含任意的字节，它的核心设计的一部分仍旧是UTF-8编码.&lt;/p></description></item></channel></rss>