<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>微服务 on 茶酒的小站</title><link>https://chajiuqqq.github.io/blogs/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link><description>Recent content in 微服务 on 茶酒的小站</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 01 Mar 2023 13:50:07 +0800</lastBuildDate><atom:link href="https://chajiuqqq.github.io/blogs/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/index.xml" rel="self" type="application/rss+xml"/><item><title>Gokit项目结构和Consul结合实现服务注册和发现</title><link>https://chajiuqqq.github.io/blogs/p/gokit%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%92%8Cconsul%E7%BB%93%E5%90%88%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/</link><pubDate>Wed, 01 Mar 2023 13:50:07 +0800</pubDate><guid>https://chajiuqqq.github.io/blogs/p/gokit%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%92%8Cconsul%E7%BB%93%E5%90%88%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/</guid><description>&lt;h1 id="go-kit的三层结构">go-kit的三层结构&lt;/h1>
&lt;p>go-kit项目采用分层架构方式。&lt;/p>
&lt;ul>
&lt;li>transport层：处理http、grpc等逻辑。比如在http中就是返回一个http.Handler，里面包含了URL和对应处理器的关系&lt;/li>
&lt;li>endpoint层：用于接受请求，处理请求，返回响应。每个服务都会包装成一个endpoint，在endpoint中调用service的方法，最后返回组装好的response。类似Java中controller的写法，不过这里没有涉及URL路径，只是提供包装后的服务。&lt;/li>
&lt;li>service层：业务代码实现层，也就是定义了有什么服务，服务的具体实现。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://chajiuqqq.github.io/blogs/blogs/p/gokit%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%92%8Cconsul%E7%BB%93%E5%90%88%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/1.png"
width="1598"
height="394"
srcset="https://chajiuqqq.github.io/blogs/blogs/p/gokit%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%92%8Cconsul%E7%BB%93%E5%90%88%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/1_hu7f74198fd50c76ee75e9c81f8c66bfea_337892_480x0_resize_box_3.png 480w, https://chajiuqqq.github.io/blogs/blogs/p/gokit%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%92%8Cconsul%E7%BB%93%E5%90%88%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/1_hu7f74198fd50c76ee75e9c81f8c66bfea_337892_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Alt text"
class="gallery-image"
data-flex-grow="405"
data-flex-basis="973px"
>&lt;/p>
&lt;p>代码中使用了go-kit的函数，影响较大的是endpoint层和transport层。写法和我们普通分层写不太一样，用了很多go-kit的API。下面我们先从service层讲起。&lt;/p>
&lt;h2 id="service层">service层&lt;/h2>
&lt;p>作为服务端，如果想要使用服务注册和发现中心，比如consul，那么服务端需要有这三个功能，&lt;strong>我们抽象为一个接口：&lt;/strong>&lt;/p>
&lt;pre>&lt;code>type DiscoveryClient interface {
/**
* 服务注册接口
* @param serviceName 服务名
* @param instanceId 服务实例Id
* @param instancePort 服务实例端口
* @param healthCheckUrl 健康检查地址
* @param instanceHost 服务实例地址
* @param meta 服务实例元数据
*/
Register(serviceName, instanceId, healthCheckUrl string, instanceHost string, instancePort int, meta map[string]string, logger *log.Logger) bool
/**
* 服务注销接口
* @param instanceId 服务实例Id
*/
DeRegister(instanceId string, logger *log.Logger) bool
/**
* 发现服务实例接口
* @param serviceName 服务名
*/
DiscoverServices(serviceName string, logger *log.Logger) []interface{}
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Register用于把自己注册到consul&lt;/li>
&lt;li>DeRegister用于向consul注销自己的服务&lt;/li>
&lt;li>DiscoverServices用于向consul请求别的服务&lt;/li>
&lt;/ul>
&lt;p>对应可以有自己的接口实现，比如定义MyDiscoverClient结构，然后实现DiscoveryClient接口，如注册方法可以自己写http请求，发送到consul注册；或者定义KitDiscoverClient结构，然后实现DiscoveryClient接口，调用go-kit的consul client进行快速注册。&lt;/p>
&lt;p>简单贴一个注册方法的go-kit实现：&lt;/p>
&lt;pre>&lt;code>func (consulClient *KitDiscoverClient) Register(serviceName, instanceId, healthCheckUrl string, instanceHost string, instancePort int, meta map[string]string, logger *log.Logger) bool {
// 1. 构建服务实例元数据
serviceRegistration := &amp;amp;api.AgentServiceRegistration{
ID: instanceId,
Name: serviceName,
Address: instanceHost,
Port: instancePort,
Meta: meta,
Check: &amp;amp;api.AgentServiceCheck{
DeregisterCriticalServiceAfter: &amp;quot;30s&amp;quot;,
HTTP: &amp;quot;http://&amp;quot; + instanceHost + &amp;quot;:&amp;quot; + strconv.Itoa(instancePort) + healthCheckUrl,
Interval: &amp;quot;15s&amp;quot;,
},
}
// 2. 发送服务注册到 Consul 中
err := consulClient.client.Register(serviceRegistration)
if err != nil {
log.Println(&amp;quot;Register Service Error!&amp;quot;)
return false
}
log.Println(&amp;quot;Register Service Success!&amp;quot;)
return true
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>第二个接口是Service接口&lt;/strong>，包含你可以提供什么服务，比如连接字符串，比如心跳检查，比如发现服务。如：&lt;/p>
&lt;pre>&lt;code>type Service interface {
// HealthCheck check service health status
HealthCheck() bool
// sayHelloService
SayHello() string
// discovery service from consul by serviceName
DiscoveryService(ctx context.Context, serviceName string) ([]interface{}, error)
}
&lt;/code>&lt;/pre>
&lt;p>然后提供自己的结构实现，如DiscoveryServiceImpl，这个结构里也可以包含上面提到的DiscoveryClient实例，这样就可以复用DiscoveryClient的实现了：&lt;/p>
&lt;pre>&lt;code>//定义接口实现的结构
type DiscoveryServiceImpl struct {
discoveryClient discover.DiscoveryClient
}
//定义工厂方法，其实不要也可以
func NewDiscoveryServiceImpl(discoveryClient discover.DiscoveryClient) Service {
return &amp;amp;DiscoveryServiceImpl{
discoveryClient:discoveryClient,
}
}
//下面是实现接口的方法
func (*DiscoveryServiceImpl) SayHello() string {
return &amp;quot;Hello World!&amp;quot;
}
func (service *DiscoveryServiceImpl) DiscoveryService(ctx context.Context, serviceName string) ([]interface{}, error) {
instances := service.discoveryClient.DiscoverServices(serviceName, config.Logger)
if instances == nil || len(instances) == 0 {
return nil, ErrNotServiceInstances
}
return instances, nil
}
// HealthCheck implement Service method
// 用于检查服务的健康状态，这里仅仅返回true
func (*DiscoveryServiceImpl) HealthCheck() bool {
return true
}
&lt;/code>&lt;/pre>
&lt;p>通过上面的工厂方法NewDiscoveryServiceImpl，可以构建出一个Service的实现，用于调用自己的各种service&lt;/p>
&lt;pre>&lt;code>// 声明并初始化 Service
var svc = service.NewDiscoveryServiceImpl(discoveryClient)
&lt;/code>&lt;/pre>
&lt;p>接下来是要把服务暴露出来，一个很简单的方法是通过URL暴露，比如将GET的/say-hello映射到Service的sayHello方法上，也就是HTTP服务器里用处理器去处理URL请求。但是go-kit使用了endpoint的概念，把服务称为endpoint，其中不包含对应的URL。&lt;/p>
&lt;p>URL和endpoint的绑定我们放在了transport层实现。&lt;/p>
&lt;h2 id="endpoint层">endpoint层&lt;/h2>
&lt;p>首先介绍endpoint层。每个服务都是一个endpoint，所以构建一个机构，包含所有的服务（endpoint）：&lt;/p>
&lt;pre>&lt;code>type DiscoveryEndpoints struct {
SayHelloEndpoint endpoint.Endpoint
DiscoveryEndpoint endpoint.Endpoint
HealthCheckEndpoint endpoint.Endpoint
}
&lt;/code>&lt;/pre>
&lt;p>上面的endpoint.Endpoint其实就是一个函数别名：&lt;/p>
&lt;pre>&lt;code>func(ctx context.Context, request interface{}) (response interface{}, err error)
&lt;/code>&lt;/pre>
&lt;p>也就是说，DiscoveryEndpoints是包含了几个函数的结构，这几个函数也就是提供请求响应服务的。&lt;/p>
&lt;p>然后需要定义每个服务的请求结构、响应结构，如：&lt;/p>
&lt;blockquote>
&lt;p>SayHelloEndpoint&amp;ndash;&amp;gt;SayHelloRequest、SayHelloResponse&lt;/p>
&lt;p>DiscoveryEndpoint&amp;ndash;&amp;gt;DiscoveryRequest、DiscoveryResponse&lt;/p>
&lt;/blockquote>
&lt;p>每个结构里就是你需要传递的数据字段，没有的话就空，同时要指明json序列化tag：&lt;/p>
&lt;pre>&lt;code>// 打招呼请求结构体
type SayHelloRequest struct {
}
// 打招呼响应结构体
type SayHelloResponse struct {
Message string `json:&amp;quot;message&amp;quot;`
}
&lt;/code>&lt;/pre>
&lt;p>然后是写函数返回这个具体的endpoint，可以看到就是返回一个函数，最后返回的是SayHelloResponse：&lt;/p>
&lt;pre>&lt;code>// 创建打招呼 Endpoint
func MakeSayHelloEndpoint(svc service.Service) endpoint.Endpoint {
return func(ctx context.Context, request interface{}) (response interface{}, err error) {
message := svc.SayHello()
return SayHelloResponse{
Message:message,
}, nil
}
}
&lt;/code>&lt;/pre>
&lt;p>如果有请求数据，如何从请求中获取？&lt;/p>
&lt;p>可以从request对象中转成你这个endpoint对应的请求结构，如&lt;code>req := request.(DiscoveryRequest)&lt;/code>，这样就可以用结构里的数据了。&lt;/p>
&lt;pre>&lt;code>// 创建服务发现的 Endpoint
func MakeDiscoveryEndpoint(svc service.Service) endpoint.Endpoint {
return func(ctx context.Context, request interface{}) (response interface{}, err error) {
req := request.(DiscoveryRequest)
instances, err := svc.DiscoveryService(ctx, req.ServiceName)
var errString = &amp;quot;&amp;quot;
if err != nil{
errString = err.Error()
}
return &amp;amp;DiscoveryResponse{
Instances:instances,
Error:errString,
}, nil
}
}
&lt;/code>&lt;/pre>
&lt;p>你可能会有疑问，为什么request直接可以转成对应的请求结构，是如何转的呢？这在后面会提到，系统会使用我们提供的反序列化方法，将请求decode为我们设计的请求结构。同理，最后response结构如何序列化发送给客户端？也是调用了我们提供的序列化方法。&lt;/p>
&lt;p>至此，endpoint构建完毕&lt;/p>
&lt;h2 id="transport层">transport层&lt;/h2>
&lt;p>如在http服务中，我们可以构建一个函数返回Handler。区别于直接提供给URL一个处理器或处理器函数，这边我们使用kithttp提供的处理器。&lt;/p>
&lt;p>我们需要提供几个参数去构建这个处理器：&lt;/p>
&lt;ul>
&lt;li>endpoint：服务处理函数，如endpoints.SayHelloEndpoint&lt;/li>
&lt;li>请求解码函数：如decodeSayHelloRequest&lt;/li>
&lt;li>响应编码函数：如encodeJsonResponse&lt;/li>
&lt;li>处理器选项&lt;/li>
&lt;/ul>
&lt;p>看看第一个服务是如何暴露的：&lt;/p>
&lt;ul>
&lt;li>映射GET的/say-hello到一个处理器&lt;/li>
&lt;li>这个处理器包含endpoints.SayHelloEndpoint用于处理请求，并返回响应&lt;/li>
&lt;li>包含decodeSayHelloRequest用于将请求解码到SayHelloRequest&lt;/li>
&lt;li>包含encodeJsonResponse用于将SayHelloRequest转为JSON格式&lt;/li>
&lt;li>最后包含几个错误处理的方式&lt;/li>
&lt;/ul>
&lt;p>see：&lt;/p>
&lt;pre>&lt;code>// MakeHttpHandler make http handler use mux
func MakeHttpHandler(ctx context.Context, endpoints endpts.DiscoveryEndpoints, logger log.Logger) http.Handler {
r := mux.NewRouter()
options := []kithttp.ServerOption{
kithttp.ServerErrorHandler(transport.NewLogErrorHandler(logger)),
kithttp.ServerErrorEncoder(encodeError),
}
r.Methods(&amp;quot;GET&amp;quot;).Path(&amp;quot;/say-hello&amp;quot;).Handler(kithttp.NewServer(
endpoints.SayHelloEndpoint,
decodeSayHelloRequest,
encodeJsonResponse,
options...,
))
r.Methods(&amp;quot;GET&amp;quot;).Path(&amp;quot;/discovery&amp;quot;).Handler(kithttp.NewServer(
endpoints.DiscoveryEndpoint,
decodeDiscoveryRequest,
encodeJsonResponse,
options...,
))
// create health check handler
r.Methods(&amp;quot;GET&amp;quot;).Path(&amp;quot;/health&amp;quot;).Handler(kithttp.NewServer(
endpoints.HealthCheckEndpoint,
decodeHealthCheckRequest,
encodeJsonResponse,
options...,
))
return r
}
&lt;/code>&lt;/pre>
&lt;p>当然上面提到的请求解码函数和响应编码函数都是自己写的，函数签名要遵照不同格式哦：&lt;/p>
&lt;pre>&lt;code>// decodeSayHelloRequest decode request params to struct
func decodeSayHelloRequest(_ context.Context, r *http.Request) (interface{}, error) {
return endpts.SayHelloRequest{}, nil
}
// decodeDiscoveryRequest decode request params to struct
func decodeDiscoveryRequest(_ context.Context, r *http.Request) (interface{}, error) {
serviceName := r.URL.Query().Get(&amp;quot;serviceName&amp;quot;)
if serviceName == &amp;quot;&amp;quot;{
return nil, ErrorBadRequest
}
return endpts.DiscoveryRequest{
ServiceName:serviceName,
}, nil
}
// decodeHealthCheckRequest decode request
func decodeHealthCheckRequest(ctx context.Context, r *http.Request) (interface{}, error) {
return endpts.HealthRequest{}, nil
}
// encodeJsonResponse encode response to return
func encodeJsonResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {
w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json;charset=utf-8&amp;quot;)
return json.NewEncoder(w).Encode(response)
}
&lt;/code>&lt;/pre>
&lt;h1 id="main函数调用">main函数调用&lt;/h1>
&lt;p>处理流程如下&lt;/p>
&lt;ol>
&lt;li>读取consulHost, consulPort&lt;/li>
&lt;li>用上述参数构建discoveryClient&lt;/li>
&lt;li>用discoveryClient构建service&lt;/li>
&lt;li>用service构建若干个endpoints&lt;/li>
&lt;li>用若干个endpoints构建transport的handler&lt;/li>
&lt;li>向consul注册自己&lt;/li>
&lt;li>用handler和端口构建并开启http服务&lt;/li>
&lt;li>监听到终止信号则向consul取消注册，并退出服务&lt;/li>
&lt;/ol>
&lt;p>注册时候有个问题，向服务中心注册时只要提交instanceId、serviceName、instanceHost、instancePort等信息，但是不包含结构化的有什么服务，服务对应的URL是什么，别人通过服务名查询到该实例，知道该实例的host和port，但是接下来怎做？我还是不知道你提供什么服务啊，不知道服务在哪个URL。&lt;/p>
&lt;p>然后调用别人的服务也是手动发送http请求吗。&lt;/p>
&lt;p>学了grpc之后，明白rpc是解决微服务之间的调用问题，而服务的注册和发现是这一章解决的，如何将二者结合？比如某个rpc服务向服务中心注册，然后客户端查询“XXX”服务，获得“XXX”服务的地址和端口，然后建立rpc连接，用rpc去调用。这是一个比较合理的逻辑。&lt;/p>
&lt;p>即服务中心解决服务在哪的问题，RPC解决服务调用、返回的问题&lt;/p></description></item><item><title>介绍一下grpc的使用</title><link>https://chajiuqqq.github.io/blogs/p/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bgrpc%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Tue, 28 Feb 2023 11:28:33 +0800</pubDate><guid>https://chajiuqqq.github.io/blogs/p/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bgrpc%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>&lt;p>gRPC和protocol buffers通常被一起使用，protoBuf是gRPC的接口定义语言，也是其底层消息交换结构。通过gRPC，一个客户端可以像调用本地方法一样调用服务端应用的方法。客户端和服务端可以在多种不同环境下互动，比如java作为服务端语言，而go、python等作为客户端语言。&lt;/p>
&lt;p>gRPC使用protoBuf作为结构化数据的序列算法，可以在&lt;code>.proto&lt;/code>文件中定义数据结构，并用&lt;code>protoc&lt;/code>生成目标语言的客户端、服务端代码。&lt;/p>
&lt;p>下面是一个例子，数据被定义为一个message，并包含一系列的域；用rpc和方法名，参数，返回值构成服务。&lt;/p>
&lt;pre>&lt;code>// The greeter service definition.
service Greeter {
// Sends a greeting
rpc SayHello (HelloRequest) returns (HelloReply) {}
}
// The request message containing the user's name.
message HelloRequest {
string name = 1;
}
// The response message containing the greetings
message HelloReply {
string message = 1;
}
&lt;/code>&lt;/pre>
&lt;p>在生成客户端、服务端代码后，还需要进一步开发使用。&lt;/p>
&lt;h1 id="string-service例子">string-service例子&lt;/h1>
&lt;p>下面以一个string-service作为例子介绍，首先定义proto文件：&lt;/p>
&lt;pre>&lt;code>syntax = &amp;quot;proto3&amp;quot;;
package pb;
option go_package = &amp;quot;grpc-string-test/pb&amp;quot;;
service StringService{
rpc Concat(StringRequest) returns (StringResponse){}
rpc Diff(StringRequest) returns (StringResponse){}
}
message StringRequest{
string A = 1;
string B = 2;
}
message StringResponse{
string Ret = 1;
string err = 2;
}
&lt;/code>&lt;/pre>
&lt;p>proto3需要加上&lt;code>option go_package = &amp;quot;grpc-string-test/pb&amp;quot;;&lt;/code>前面是model名，后面是包名。这样才能生成成功。&lt;/p>
&lt;p>编译代码是：&lt;/p>
&lt;pre>&lt;code>protoc --go_out=. --go_opt=paths=source_relative \
--go-grpc_out=. --go-grpc_opt=paths=source_relative \
string.proto
&lt;/code>&lt;/pre>
&lt;p>这个命令需要到proto文件的目录执行。最后string.proto是要转换的proto文件名。最后会在当前目录下生成两个文件&lt;code>string.pb.go&lt;/code>和&lt;code>string_grpc.pb.go&lt;/code>，客户端和服务端都需要用到这两个文件。&lt;/p>
&lt;h2 id="server端">server端&lt;/h2>
&lt;p>为了实现具体的Concat和Diff方法，需要建立一个结构，并实现StringServiceServer接口&lt;/p>
&lt;p>你首先可以这么做：&lt;/p>
&lt;pre>&lt;code>type StringService struct {
pb.UnimplementedStringServiceServer
}
&lt;/code>&lt;/pre>
&lt;p>嵌入UnimplementedStringServiceServer，这是自动生成的一个结构，这样就默认实现了StringServiceServer接口，然后再重写Concat和Diff方法：&lt;/p>
&lt;pre>&lt;code>func (s *StringService) Concat(ctx context.Context, req *StringRequest) (*StringResponse, error) {
log.Println(req)
if len(req.A)+len(req.B) &amp;gt; StrMaxSize {
response := StringResponse{Ret: &amp;quot;&amp;quot;}
return &amp;amp;response, nil
}
response := StringResponse{Ret: req.A + req.B}
return &amp;amp;response, nil
}
func (s *StringService) Diff(ctx context.Context, req *StringRequest) (*StringResponse, error) {
log.Println(req)
if len(req.A) &amp;lt; 1 || len(req.B) &amp;lt; 1 {
response := StringResponse{Ret: &amp;quot;&amp;quot;}
return &amp;amp;response, nil
}
res := &amp;quot;&amp;quot;
if len(req.A) &amp;gt;= len(req.B) {
for _, char := range req.B {
if strings.Contains(req.A, string(char)) {
res = res + string(char)
}
}
} else {
for _, char := range req.A {
if strings.Contains(req.B, string(char)) {
res = res + string(char)
}
}
}
response := StringResponse{Ret: res}
return &amp;amp;response, nil
}
&lt;/code>&lt;/pre>
&lt;p>注意到传入参数是StringRequest，返回StringResponse，也就是我们之前定义的消息结构。&lt;/p>
&lt;p>写好了业务到底如何实现，下面要开启server对端口的监听，接受rpc请求，流程如下：&lt;/p>
&lt;ul>
&lt;li>获取某端口的Listener&lt;/li>
&lt;li>新建grpc.Server和上面我们定义的StringService&lt;/li>
&lt;li>调用RegisterStringServiceServer向grpc.Server注册StringService&lt;/li>
&lt;li>开启rpc监听&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> func main() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lis, err := net.Listen(&amp;#34;tcp&amp;#34;, &amp;#34;127.0.0.1:1234&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if err != nil {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> log.Fatalf(&amp;#34;failed to listen: %v&amp;#34;, err)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> log.Println(&amp;#34;server at 127.0.0.1:1234&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> grpcServer := grpc.NewServer()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> stringService := new(service.StringService)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> pb.RegisterStringServiceServer(grpcServer, stringService)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> grpcServer.Serve(lis)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="client端">client端&lt;/h2>
&lt;p>client只要建立rpc连接，然后调用服务即可。流程如下：&lt;/p>
&lt;ul>
&lt;li>grpc.Dial拨号建立rpc连接，获得conn&lt;/li>
&lt;li>从conn获取stringClient，这个变量实现的接口包含所有提供的服务&lt;/li>
&lt;li>由stringClient调用各种服务&lt;/li>
&lt;/ul>
&lt;p>注意传入参数是我们之前定义的StringRequest，返回StringResponse，非常完美&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> func main() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> serviceAddress := &amp;#34;127.0.0.1:1234&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> conn, err := grpc.Dial(serviceAddress, grpc.WithInsecure())
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if err != nil {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> panic(&amp;#34;connect error&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> defer conn.Close()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> stringClient := pb.NewStringServiceClient(conn)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> stringReq := &amp;amp;pb.StringRequest{A: &amp;#34;A&amp;#34;, B: &amp;#34;B&amp;#34;}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> reply, _ := stringClient.Concat(context.Background(), stringReq)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> fmt.Printf(&amp;#34;StringService Concat : %s concat %s = %s\n&amp;#34;, stringReq.A, stringReq.B, reply.Ret)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>至此，server和client都写完了，开启server，然后开启client，就可以进行rpc调用。&lt;/p>
&lt;h1 id="使用流的string-service例子">使用流的string-service例子&lt;/h1>
&lt;p>流指的是请求消息流或响应消息流，每个单位都是对应的请求结构或响应结构，并持续发送，好处是可以连续发送，连续处理。而不是发一个返回一个，发一个返回一个。&lt;/p>
&lt;p>grpc支持单向流或双向流。在proto文件中给参数添加&lt;code>stream&lt;/code>关键字就可以指明这是以流的形式发送的参数（或结果）：&lt;/p>
&lt;pre>&lt;code>service StringService{
rpc Concat(StringRequest) returns (StringResponse){}
rpc Diff(StringRequest) returns (StringResponse){}
rpc ConcatServerStream(StringRequest) returns (stream StringResponse){}
rpc ConcatClientStream(stream StringRequest) returns (StringResponse){}
rpc ConcatDoubleStream(stream StringRequest) returns (stream StringResponse){}
}
&lt;/code>&lt;/pre>
&lt;h2 id="server发流">server发流&lt;/h2>
&lt;p>这指的是，客户端发一个req，服务端流返回res，客户端读取res流。我们要关注的就是client调用服务，接受流请求的过程；和服务端发送流的写法。&lt;/p>
&lt;pre>&lt;code>//client
func streamServerConn(stringClient pb.StringServiceClient) {
stringReq := &amp;amp;pb.StringRequest{A: &amp;quot;A&amp;quot;, B: &amp;quot;B&amp;quot;}
//接受流
stream, _ := stringClient.ConcatServerStream(context.Background(), stringReq)
//循环读取流
for {
item, err := stream.Recv()
if err == io.EOF {
break
}
if err != nil {
log.Println(&amp;quot;fail to recv:&amp;quot;, err)
}
fmt.Printf(&amp;quot;StringService Concat : %s concat %s = %s\n&amp;quot;, stringReq.A, stringReq.B, item.Ret)
}
}
//server
func (s *StringService) ConcatServerStream(req *StringRequest, qs StringService_ConcatServerStreamServer) error {
response := StringResponse{Ret: req.A + req.B}
for i := 0; i &amp;lt; 10; i++ {
qs.Send(&amp;amp;response)
}
return nil
}
&lt;/code>&lt;/pre>
&lt;h2 id="client发流">client发流&lt;/h2>
&lt;pre>&lt;code>//client
func streamClientConn(stringClient pb.StringServiceClient) {
stream, err := stringClient.ConcatClientStream(context.Background())
//流式发送requset
for i := 0; i &amp;lt; 10; i++ {
if err != nil {
log.Println(&amp;quot;fail to call:&amp;quot;, err)
break
}
stream.Send(&amp;amp;pb.StringRequest{A: strconv.Itoa(i), B: strconv.Itoa(i + 1)})
}
//发完后读取一个response
recv, err := stream.CloseAndRecv()
if err != nil {
log.Println(&amp;quot;fail to recv:&amp;quot;, err)
}
fmt.Printf(&amp;quot;Ret is %s\n&amp;quot;, recv.Ret)
}
//server
func (s *StringService) ConcatClientStream(qs StringService_ConcatClientStreamServer) error {
var params []string
for {
item, err := qs.Recv()
//客户端发完了，服务器才处理并返回一个response
if err == io.EOF {
qs.SendAndClose(&amp;amp;StringResponse{Ret: strings.Join(params, &amp;quot;&amp;quot;)})
return nil
}
if err != nil {
log.Println(&amp;quot;fail to recv:&amp;quot;, err)
return err
}
params = append(params, item.A, item.B)
}
}
&lt;/code>&lt;/pre>
&lt;h2 id="双向流">双向流&lt;/h2>
&lt;pre>&lt;code>//client
func doubleStreamConn(stringClient pb.StringServiceClient) {
stream, _ := stringClient.ConcatDoubleStream(context.Background())
var i int
for {
err := stream.Send(&amp;amp;pb.StringRequest{A: strconv.Itoa(i), B: strconv.Itoa(i + 1)})
if err != nil {
log.Println(&amp;quot;fail to send:&amp;quot;, err)
break
}
recv, err := stream.Recv()
if err != nil {
log.Println(&amp;quot;fail to recv:&amp;quot;, err)
break
}
fmt.Printf(&amp;quot;Ret is %s\n&amp;quot;, recv.Ret)
i++
time.Sleep(time.Second)
}
}
//server
func (s *StringService) ConcatDoubleStream(qs StringService_ConcatDoubleStreamServer) error {
for {
in, err := qs.Recv()
if err == io.EOF {
return nil
}
if err != nil {
log.Println(&amp;quot;fail to recv:&amp;quot;, err)
return err
}
qs.Send(&amp;amp;StringResponse{Ret: in.A + in.B})
}
}
&lt;/code>&lt;/pre>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>流传输：&lt;/p>
&lt;ul>
&lt;li>发送一个message：stream.send()&lt;/li>
&lt;li>接受一个message：stream.recv()&lt;/li>
&lt;li>发送一个msg，并关闭：stream.SendAndClose()&lt;/li>
&lt;li>接受一个msg，并关闭：stream.CloseAndRecv()&lt;/li>
&lt;li>判断流是否结束：err == io.EOF&lt;/li>
&lt;/ul></description></item><item><title>一个使用Go Rpc库实现的RPC例子</title><link>https://chajiuqqq.github.io/blogs/p/%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8go-rpc%E5%BA%93%E5%AE%9E%E7%8E%B0%E7%9A%84rpc%E4%BE%8B%E5%AD%90/</link><pubDate>Sat, 25 Feb 2023 13:14:03 +0800</pubDate><guid>https://chajiuqqq.github.io/blogs/p/%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8go-rpc%E5%BA%93%E5%AE%9E%E7%8E%B0%E7%9A%84rpc%E4%BE%8B%E5%AD%90/</guid><description>&lt;p>本文使用go rpc库实现服务的创建、客户端的请求。&lt;/p>
&lt;p>server提供字符串拼接和字符串区别的服务，运行在127.0.0.1:1234。client可以调用rpc发送请求，调用server上的服务，并获取到结果。&lt;/p>
&lt;p>&lt;strong>注意点：&lt;/strong>&lt;/p>
&lt;p>client和server都要维护请求参数结构和响应参数结构，如拼接字符串的请求参数：&lt;/p>
&lt;pre>&lt;code>type StringRequest struct {
A string
B string
}
&lt;/code>&lt;/pre>
&lt;p>响应结构这里用string即可，所以没有专门定义结构。&lt;/p>
&lt;p>client调用Call或Go方法，传入远程方法名（结构+方法，如&lt;code>StringService.Concat&lt;/code>）、请求结构、响应结构的指针，等待结果完成即可。&lt;/p>
&lt;p>&lt;strong>结果：&lt;/strong>&lt;/p>
&lt;p>server运行：&lt;/p>
&lt;pre>&lt;code>go build &amp;amp;&amp;amp; ./rpc-server
2023/02/25 13:11:20 server at 127.0.0.1:1234
&lt;/code>&lt;/pre>
&lt;p>运行client：&lt;/p>
&lt;pre>&lt;code>go build &amp;amp;&amp;amp; ./rpc-client
StringService Concat : A concat B = AB
StringService Diff : ABC diff BCD = BC
&lt;/code>&lt;/pre>
&lt;h2 id="server">server&lt;/h2>
&lt;p>StringService是实现了Service接口的结构。&lt;/p>
&lt;h3 id="servergo">server.go&lt;/h3>
&lt;pre>&lt;code>package service
import (
&amp;quot;errors&amp;quot;
&amp;quot;strings&amp;quot;
)
type StringRequest struct{
A string
B string
}
type Service interface {
Concat(req StringRequest, ret *string) error
Diff(req StringRequest, ret *string) error
}
type StringService struct {
}
const (
StrMaxSize = 1024
)
var (
ErrMaxSize = errors.New(&amp;quot;over max size of 1024&amp;quot;)
ErrStrValue = errors.New(&amp;quot;maximum size of 1024 bytes exceeded&amp;quot;)
)
func (s StringService) Concat(req StringRequest, ret *string) error {
if len(req.A)+len(req.B) &amp;gt; StrMaxSize {
*ret = &amp;quot;&amp;quot;
return ErrMaxSize
}
*ret = req.A + req.B
return nil
}
func (s StringService) Diff(req StringRequest, ret *string) error {
if len(req.A) &amp;lt; 1 || len(req.B) &amp;lt; 1 {
*ret = &amp;quot;&amp;quot;
return nil
}
res := &amp;quot;&amp;quot;
if len(req.A) &amp;gt;= len(req.B) {
for _, char := range req.B {
if strings.Contains(req.A, string(char)) {
res = res + string(char)
}
}
} else {
for _, char := range req.A {
if strings.Contains(req.B, string(char)) {
res = res + string(char)
}
}
}
*ret = res
return nil
}
&lt;/code>&lt;/pre>
&lt;h3 id="maingo">main.go&lt;/h3>
&lt;pre>&lt;code>package main
import (
&amp;quot;log&amp;quot;
&amp;quot;net&amp;quot;
&amp;quot;net/http&amp;quot;
&amp;quot;net/rpc&amp;quot;
&amp;quot;rpc-server/service&amp;quot;
)
func main() {
stringService := new(service.StringService)
rpc.Register(stringService)
rpc.HandleHTTP()
l, e := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:1234&amp;quot;)
if e != nil {
log.Fatal(&amp;quot;listen error,&amp;quot;, e)
}
log.Println(&amp;quot;server at 127.0.0.1:1234&amp;quot;)
http.Serve(l, nil)
}
&lt;/code>&lt;/pre>
&lt;h2 id="client">Client&lt;/h2>
&lt;h3 id="servergo-1">server.go&lt;/h3>
&lt;pre>&lt;code>package service
type StringRequest struct {
A string
B string
}
&lt;/code>&lt;/pre>
&lt;h3 id="maingo-1">main.go&lt;/h3>
&lt;pre>&lt;code>package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;log&amp;quot;
&amp;quot;net/rpc&amp;quot;
&amp;quot;rpc-client/service&amp;quot;
)
func main() {
client, err := rpc.DialHTTP(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:1234&amp;quot;)
if err != nil {
log.Fatal(&amp;quot;dialing:&amp;quot;, err)
}
stringReq := &amp;amp;service.StringRequest{&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;}
var reply string
err = client.Call(&amp;quot;StringService.Concat&amp;quot;, stringReq, &amp;amp;reply)
if err != nil {
log.Fatal(&amp;quot;Concat err:&amp;quot;, err)
}
fmt.Printf(&amp;quot;StringService Concat : %s concat %s = %s\n&amp;quot;, stringReq.A, stringReq.B, reply)
stringReq = &amp;amp;service.StringRequest{&amp;quot;ABC&amp;quot;, &amp;quot;BCD&amp;quot;}
call := client.Go(&amp;quot;StringService.Diff&amp;quot;, stringReq, &amp;amp;reply, nil)
_ = &amp;lt;-call.Done
fmt.Printf(&amp;quot;StringService Diff : %s diff %s = %s\n&amp;quot;, stringReq.A, stringReq.B, reply)
}
&lt;/code>&lt;/pre></description></item></channel></rss>