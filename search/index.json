[{"content":"本文记录了一下内容：\ngolang的单元测试、基准测试、http测试 测试替身和依赖注入 第三方Go测试库，gocheck，ginkgo 目录：\ngo应用测试概述 单元测试 跳过测试用例 设置并行运行的单元测试数量 基准测试 如何测试http 生命周期函数（我自己取的名字） 测试替身和依赖注入 第三方go检测库 gocheck ginkgo go应用测试概述 go的testing包用于测试，net/http/httptest用于测试web程序。对于源码文件server.go，可以在同目录下创建server_test.go文件，定义func TestXxx(*testing.T)函数。函数内部使用Error、Fail等方法表示测试失败，如果测试时没有出现任何失败，则表示测试通过。\n编写完测试文件后，在当前目录下用go test测试所有测试文件。\n单元测试 如果一个部分能独立进行测试，那被称为“单元”。向单元输入数据，并检查输出是否符合预期就是单元测试。\ntesting.T中的有用的方法：\nLog，Logf：把文本记录到错误日志中，不终止测试 Fail：标记当前测试单元“失败” FailNow：标记当前测试函数“失败”，并终止当前测试单元 Error,Errorf,Fatal,Fatalf是上述函数的复合，见下表。\nLog Logf Fail Error Errorf FailNow Fatal Fatalf 这些方法只对当前单元有效。\n单元测试中的命令：\n-v获取详细测试信息 -cover输出代码覆盖率 如go test -v -cover\n跳过测试用例 如果在单元测试中调用t.Skip()函数，则会在执行到这一行时跳过该测试单元的其余部分。\n命令中也提供这么个flag，用于逻辑判断：-short，当设置了-short时（如go test -v -cover -short），代码中调用testing.Short()返回true.\n将-short和t.Skip()结合使用，可实现命令行控制是否跳过某些测试函数，如：\nfunc TestXxxx(t *testing.T){ if testing.Short(){ t.Skip(\u0026quot;skip for short flag.\u0026quot;) } ... } 设置并行运行的单元测试数量 利用-parallel n设置并行运行的单元测试数量。如go test -v -parallel 3表示最多并行运行3个单元测试。\n基准测试 利用-bench [函数名的正则表达式]flag，执行*_test.go中定义的基准函数的测试，用于评估函数的性能。基准函数格式：\nfunc BenchmarkXxx(*testing.B){...} 通常在其中添加循环，执行b.N次程序，以此观察程序性能：\nfunc BenchmarkXxx(b *testing.B){ for i:=0;i\u0026lt;b.N;i++{ ... } } 执行所有单元测试和基准函数：go test -v -bench .\n如要忽略单元测试，使用-run [函数名的正则表达式]来指定要运行的单元测试。设置为-run none则会忽略所有单元测试。结合一下，go test -v -run none -bench .就只会执行基准测试了。\n如何测试http 测试http就是在测试处理器函数，这种函数接受http.ResponseWriter和*http.Request.问题在于如何提供这两个参数。我们可以在测试函数中伪造http server、http请求，并把response记录下来，实现伪造http整个流程，从而实现测试。\n下面代码实现了对处理器函数的测试：\n伪造一个http server 指定要测试的处理器函数和路径 伪造GET请求 把response记录在httptest.ResponseRecorder中 读取response，看程序是否符合预期 func TestHandleGet(t *testing.T) { mux := http.NewServeMux() mux.HandleFunc(\u0026quot;/post/\u0026quot;, handleRequest) writer := httptest.NewRecorder() req, _ := http.NewRequest(\u0026quot;GET\u0026quot;, \u0026quot;/post/1\u0026quot;, nil) mux.ServeHTTP(writer, req) if writer.Code != 200 { t.Errorf(\u0026quot;response code is %d\u0026quot;, writer.Code) } var post data.Post json.Unmarshal(writer.Body.Bytes(), \u0026amp;post) if post.Id != 1 { t.Error(\u0026quot;can't retrieve JSON post\u0026quot;) } } 生命周期函数（我自己取的名字） 为了在测试前、测试后统一执行一些共有的代码，可以利用生命周期函数实现。首先定义函数TestMain\nfunc TestMain(m *testing.M) { setUp() code := m.Run() tearDown() os.Exit(code) } setUp()和tearDown()都是为所有测试用例定义的函数，m.Run()会调用测试案例，所以setUp()在测试前执行，tearDown()在测试后执行。并且在整个测试中只会执行一次。\n上述TestHandleGet方法我们也可以优化为：\nvar mux *http.ServeMux var writer *httptest.ResponseRecorder func TestMain(m *testing.M) { setUp() code := m.Run() os.Exit(code) } func setUp() { mux = http.NewServeMux() mux.HandleFunc(\u0026quot;/post/\u0026quot;, handleRequest) writer = httptest.NewRecorder() } func TestHandleGet(t *testing.T) { req, _ := http.NewRequest(\u0026quot;GET\u0026quot;, \u0026quot;/post/1\u0026quot;, nil) mux.ServeHTTP(writer, req) if writer.Code != 200 { t.Errorf(\u0026quot;response code is %d\u0026quot;, writer.Code) } var post data.Post json.Unmarshal(writer.Body.Bytes(), \u0026amp;post) if post.Id != 1 { t.Error(\u0026quot;can't retrieve JSON post\u0026quot;) } } 这样就把mux和writer作为全局变量。测试开始前进行初始化设置。\n测试替身和依赖注入 为了不在测试中执行真实的操作，如测试邮件发送不希望真的发送邮件；测试数据库不希望真的修改数据库（某些场景下），我们需要用接口来实现依赖注入（替换实际对象），由依赖关系代替实际的操作，实现层的解耦。\n第三方go检测库 gocheck 这是一个基于testing构建的测试框架。安装：go get gopkg.in/check.v1\n有几个特点：\n以suite为单位分组测试（测试某个结构里的所有测试方法） suite或单个测试用例粒度的生命周期函数（测试夹具） 。。。 使用例子，只有注册过的Suite才会被测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import( . \u0026#34;gopkg.in/check.v1\u0026#34; ) //定义suite type XxxSuite struct{} //注册suite,只有注册过的Suite才会被测试 func init(){ Suite(\u0026amp;XxxSuite{}) } //定义suite里的测试方法 func (x *XxxSuite) TestHandleGet(c *C){ ... c.Check(code,Equals,200) ... } go test -check.vv 会显示更详细的日志\n测试夹具（预定义的生命周期函数）：\nsuite粒度（当前套件执行前后调用） SetUpSuite TearDownSuite 测试用例粒度（当前套件的每个测试用例执行前后调用） SetUpTest TearDownTest 注意这几个函数需要定义在suite内，如：func (x *XxxSuite) SetUpSuite(c *C){} func (x *XxxSuite) SetUpTest(c *C){}\nginkgo 一个行为驱动开发（BDD）风格的Go测试框架。主要用于实现BDD，但是这里只用作测试框架使用。\nBDD，软件由目标行为定义。这些行为也就是业务需求，如：\n1、用ginkgo转换已存在的测试用例为BDD风格\n在包含测试文件的目录下执行ginkgo convert .，会生成xxx_suite_test.go（相当于原来testing的入口），并对原xxx_test.go进行修改，因此注意备份。\n2、自己编写ginkgo用例\n用到2个命令：\nginkgo bootstrap:创建引导文件（我取的名字），类似xxx_suite_test.go ginkgo generate:创建测试用例文件的骨架： 这里首先再导入一个断言包Gomega，为啥要用这个呢，可能功能更强大吧。\ngo get github.com/onsi/gomega\n接下来就在这个Describe函数里描述用户故事、情景。也就是用他给定的格式写测试代码。\n当然ginkgo的测试夹具（预定义的生命周期函数）也不可少，BeforeEach()会在每个情景前执行(也就是每个context函数前执行)：\n","date":"2023-02-15T11:31:41+08:00","permalink":"http://blogs.chajiuqqq.cn/p/golang%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95/","title":"Golang中的应用测试"},{"content":"Golang中的数据存储有三种方案：\n利用容器的内存存储（非内存数据库） 利用文件读写的存储（文本文件如csv、二进制文件如gob） 数据库存储 本文简述后面两种。\n文件存储 下面展示了golang中读写文件的常用方式。\nioutil的函数读写文件 os创建File，再读写文件 code:\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;io/ioutil\u0026quot; \u0026quot;os\u0026quot; ) func main() { //ioutil读写文件 data := []byte(\u0026quot;hello world!\u0026quot;) err := ioutil.WriteFile(\u0026quot;data1\u0026quot;, data, 0644) if err != nil { panic(err) } read1, _ := ioutil.ReadFile(\u0026quot;data1\u0026quot;) fmt.Println(string(read1)) //os读写文件 file1, _ := os.Create(\u0026quot;data2\u0026quot;) defer file1.Close() nbytes, _ := file1.Write(data) fmt.Printf(\u0026quot;wrote %d bytes to file\\n\u0026quot;, nbytes) file2, _ := os.Open(\u0026quot;data2\u0026quot;) defer file2.Close() read2 := make([]byte, len(data)) nbytes, _ = file2.Read(read2) fmt.Printf(\u0026quot;Read %d bytes from file\\n\u0026quot;, nbytes) fmt.Println(string(read2)) } // hello world! wrote 12 bytes to file Read 12 bytes from file hello world! csv读写 利用\u0026quot;encoding/csv\u0026quot;可实现csv读写，下面是小例子。将File传给csv.NewWriter()或csv.NewReader()\npackage main import ( \u0026quot;encoding/csv\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; \u0026quot;strconv\u0026quot; ) type Post struct { Id int Content string Author string } func main() { csvFile, err := os.Create(\u0026quot;posts.csv\u0026quot;) if err != nil { panic(err) } defer csvFile.Close() allPosts := []Post{ Post{1, \u0026quot;hello world 1\u0026quot;, \u0026quot;Jack1\u0026quot;}, Post{2, \u0026quot;hello world 2\u0026quot;, \u0026quot;Jack2\u0026quot;}, Post{3, \u0026quot;hello world 3\u0026quot;, \u0026quot;Jack3\u0026quot;}, Post{4, \u0026quot;hello world 4\u0026quot;, \u0026quot;Jack4\u0026quot;}, Post{5, \u0026quot;hello world 5\u0026quot;, \u0026quot;Jack5\u0026quot;}, } writer := csv.NewWriter(csvFile) for _, post := range allPosts { line := []string{strconv.Itoa(post.Id), post.Content, post.Author} if err := writer.Write(line); err != nil { panic(err) } } writer.Flush() file, err := os.Open(\u0026quot;posts.csv\u0026quot;) if err != nil { panic(err) } defer file.Close() reader := csv.NewReader(file) reader.FieldsPerRecord = -1 records, err := reader.ReadAll() if err != nil { panic(err) } var posts []Post for _, item := range records { id, _ := strconv.Atoi(item[0]) post := Post{id, item[1], item[2]} posts = append(posts, post) } fmt.Println(posts[0].Id) fmt.Println(posts[0].Content) fmt.Println(posts[0].Author) } 生成posts.csv:\n1,hello world 1,Jack1 2,hello world 2,Jack2 3,hello world 3,Jack3 4,hello world 4,Jack4 5,hello world 5,Jack5 gob读写 利用\u0026quot;encoding/gob\u0026quot;包，gob.NewEncoder()接受一个io.Writer; gob.NewDecoder()接受一个io.Reader.\n也就是说，可以提供一个buffer，供编码时存储结果；供解码时存储输入。\n最后传入\u0026amp;postRecord才能修改原变量内容。\npackage main import ( \u0026quot;bytes\u0026quot; \u0026quot;encoding/gob\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;io/ioutil\u0026quot; ) type Post struct { Id int Content string Author string } func store(data interface{}, filename string) { buffer := new(bytes.Buffer) encoder := gob.NewEncoder(buffer) err := encoder.Encode(data) if err != nil { panic(err) } err = ioutil.WriteFile(filename, buffer.Bytes(), 0600) if err != nil { panic(err) } } func load(data interface{}, filename string) { raw, err := ioutil.ReadFile(filename) if err != nil { panic(err) } buffer := bytes.NewBuffer(raw) decoder := gob.NewDecoder(buffer) err = decoder.Decode(data) if err != nil { panic(err) } } func main() { post := Post{1, \u0026quot;hello world\u0026quot;, \u0026quot;jack\u0026quot;} store(post, \u0026quot;post1\u0026quot;) var postRecord Post load(\u0026amp;postRecord, \u0026quot;post1\u0026quot;) fmt.Println(postRecord) } 利用database/sql连接数据库并执行CRUD 首先需要注入对应的数据库驱动，如postgres常用github.com/lib/pq驱动。在main包中注入：\nimport( _ \u0026quot;github.com/lib/pq\u0026quot; ) 数据库连接，使用sql.Open(数据库名称，数据源字符串)，其中数据源字符串需要符合对应驱动的格式，如pq的话，有这么几种合法的格式：\n\u0026ldquo;user=pqgotest dbname=pqgotest sslmode=verify-full\u0026rdquo; \u0026ldquo;postgres://pqgotest:password@localhost/pqgotest?sslmode=verify-full\u0026rdquo; 见 https://pkg.go.dev/github.com/lib/pq\nCRUD总结：\n预处理语句：使用sql.Stmt结构\nstmt,err := db.Prepare(\u0026quot;...\u0026quot;) 执行语句并获取一个sql.Row,一般后跟Scan(),用于把这一行读取到某些变量中\ndb.QueryRow(\u0026quot;...\u0026quot;, , ) 或 stmt.QueryRow( , ) 执行并获取多个sql.Row:\nrows,err := db.Query(\u0026quot;...\u0026quot;, , ) rows.Next() rows.Scan() 直接执行语句，只返回最后插入ID(如果insert)、影响的行数（insert、update、delete），不返回查询结果：\nres,err := db.Exec(\u0026quot;...\u0026quot;, , ) go orm 关系映射器 ORM 思想是将数据结构和表结构相对应。Gorm是go里最棒的ORM。\n","date":"2023-02-12T08:47:06+08:00","permalink":"http://blogs.chajiuqqq.cn/p/golang%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/","title":"Golang中的数据存储"},{"content":" go-in-action里的一个demo，给定需要匹配的字符串，在搜索源（如rss）中批量查询最新文章，返回结果（如相匹配的title和description）\n关键字：goroutine并发，json/xml反序列化，网络请求\n项目地址：https://github.com/chajiuqqq/go-rss-matcher\n效果：搜索“China”，发现了近期和China相关的文章，如中国气球误入美国:\n$ ./rss-matcher 2023/02/04 12:04:33 title China says balloon spotted over U.S. is a 'civilian airship' that blew astray 2023/02/04 12:04:33 description The State Department announced Secretary of State Antony Blinken will not go ahead with a planned trip to China, after the surveillance balloon was detected over U.S. airspace Thursday. 2023/02/04 12:04:33 title Tensions continue to increase between the United States and China 2023/02/04 12:04:34 HTTP Response Error: http://www.npr.org/rss/rss.php?id=43 code 404 2023/02/04 12:04:34 HTTP Response Error: http://www.npr.org/rss/rss.php?id=1021 code 404 2023/02/04 12:04:34 title Perspective: Jiang Zemin's passing marks the end of an era for China 2023/02/04 12:04:34 description As China holds a memorial service for its late leader Jiang Zemin, an NPR correspondent who met Jiang reflects on the figure and his transforming country. 2023/02/04 12:04:34 title Blinken postpones China trip after discovery of surveillance balloon 2023/02/04 12:04:34 description Secretary of State Antony Blinken has postponed his trip to China after the discovery of what the Pentagon alleges to be a Chinese surveillance balloon. China's government says it's a weather balloon. 2023/02/04 12:04:34 title China says balloon spotted over U.S. is a 'civilian airship' that blew astray 2023/02/04 12:04:34 description The State Department announced Secretary of State Antony Blinken will not go ahead with a planned trip to China, after the surveillance balloon was detected over U.S. airspace Thursday. 2023/02/04 12:04:34 description China's foreign ministry described the balloon as \u0026quot;a civilian airship\u0026quot; for meteorological research that had blown far off course by winds. The Pentagon suspects it's collecting sensitive information. 项目结构设计上支持多种搜索源，如rss等，只要设计对应的matcher就可以进行搜索匹配。\n程序流程如下：\n读取data.json里的搜索源（feeds），并反序列化为对象供后面访问 给每个feed寻找已注册的matcher匹配器，并开启goroutine匹配。匹配结果写入通道。 匹配过程首先请求feed的URL，获得XML 解析xml，反序列化到对象 对对象里的字段进行匹配 循环读取通道内的结果，并打印 如果匹配结束，关闭通道，主程序结束 几个设计上的亮点：\n设计Matcher接口，所有的matcher都可以调用Search进行搜索 设计matcherMap，不同类型的Matcher注册后保存在这里，方便不同数据源匹配和数据源类型拓展 每个goroutine执行一个feed的搜索，并发执行，提高性能 查询结果后，goroutine通过无缓冲chan把数据发送主线程展示，同步获取并展示，利用了语言特性 ","date":"2023-02-07T12:01:09+08:00","permalink":"http://blogs.chajiuqqq.cn/p/%E4%B8%80%E4%B8%AAgolang-rss%E5%86%85%E5%AE%B9%E5%8C%B9%E9%85%8D%E5%99%A8/","title":"一个Golang RSS内容匹配器"},{"content":"标准库的log包无法实现日志分级处理，这个demo可以实现日志的多级处理。原理是定义多个log对象，并指定不同的输出，实现不同等级日志不同输出。\nmlog包代码如下：\n// mlog.go package mlog import ( \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) var ( Trace *log.Logger Info *log.Logger Warning *log.Logger Error *log.Logger ) func init() { file, err := os.OpenFile(\u0026quot;error.txt\u0026quot;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666) if err != nil { log.Fatalln(\u0026quot;Fail to open error file:\u0026quot;, err) } Trace = log.New(io.Discard, \u0026quot;TRACE: \u0026quot;, log.Ldate|log.Ltime|log.Lshortfile) Info = log.New(os.Stdout, \u0026quot;INFO: \u0026quot;, log.Ldate|log.Ltime|log.Lshortfile) Warning = log.New(os.Stdout, \u0026quot;WARNING: \u0026quot;, log.Ldate|log.Ltime|log.Lshortfile) Error = log.New(file, \u0026quot;ERROR: \u0026quot;, log.Ldate|log.Ltime|log.Lshortfile) } 调用测试：\npackage main import \u0026quot;github.com/chajiu/go-example/mlog\u0026quot; func main() { mlog.Trace.Println(\u0026quot;trace...\u0026quot;) mlog.Info.Println(\u0026quot;Info...\u0026quot;) mlog.Warning.Println(\u0026quot;warning...\u0026quot;) mlog.Error.Println(\u0026quot;error...\u0026quot;) } error.txt会在main目录下生成。\nERROR: 2023/02/07 10:56:13 main.go:9: error... ERROR: 2023/02/07 10:56:23 main.go:9: error... Info和Warning则是直接输出到stdout：\nINFO: 2023/02/07 10:56:23 main.go:7: Info... WARNING: 2023/02/07 10:56:23 main.go:8: warning... ","date":"2023-02-07T11:03:38+08:00","permalink":"http://blogs.chajiuqqq.cn/p/%E4%B8%80%E4%B8%AAgolang%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E5%99%A8/","title":"一个golang自定义日志记录器"},{"content":"实验室二次开发一个blockly平台，这是一个积木化编程平台，可从积木生成各种语言代码，如Python。界面如下，积木到代码由原blockly库提供，不难。 而运行python代码刚开始是放在jupyter notebook，手动复制过去运行。 进一步优化的方案就是在线运行（在浏览器）Python代码。基本库的浏览器化不难，但是之前一直没找到可以运行第三方库如pandas的js库。这次看到pyodide，可以实现第三方库的导入。于是开始折腾。\n初步运行pyodide 直接看官网的例子，可以直接跑python基础库：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/pyodide/v0.21.3/full/pyodide.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt; You can execute any Python code. Just enter something in the box below and click the button. \u0026lt;/p\u0026gt; \u0026lt;input id=\u0026quot;code\u0026quot; value=\u0026quot;sum([1, 2, 3, 4, 5])\u0026quot; /\u0026gt; \u0026lt;button onclick=\u0026quot;evaluatePython()\u0026quot;\u0026gt;Run\u0026lt;/button\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;div\u0026gt;Output:\u0026lt;/div\u0026gt; \u0026lt;textarea id=\u0026quot;output\u0026quot; style=\u0026quot;width: 100%;\u0026quot; rows=\u0026quot;6\u0026quot; disabled\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;script\u0026gt; const output = document.getElementById(\u0026quot;output\u0026quot;); const code = document.getElementById(\u0026quot;code\u0026quot;); function addToOutput(s) { output.value += \u0026quot;\u0026gt;\u0026gt;\u0026gt;\u0026quot; + code.value + \u0026quot;\\n\u0026quot; + s + \u0026quot;\\n\u0026quot;; } output.value = \u0026quot;Initializing...\\n\u0026quot;; // init Pyodide async function main() { let pyodide = await loadPyodide(); output.value += \u0026quot;Ready!\\n\u0026quot;; return pyodide; } let pyodideReadyPromise = main(); async function evaluatePython() { let pyodide = await pyodideReadyPromise; try { let output = pyodide.runPython(code.value); addToOutput(output); } catch (err) { addToOutput(err); } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; print问题 基本库python代码可以正常运行，但是运行print('abc')函数时，发现打印的东西不在返回的结果里，而是在console里。幸运的是这个问题也有issue。\n这个issue下面的这个回答提供了一种方法，可以将执行的代码的输出转到返回结果，而不是console。\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; // set the pyodide files URL (packages.json, pyodide.asm.data etc) window.languagePluginUrl = 'https://cdn.jsdelivr.net/pyodide/v0.16.1/full/'; \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/pyodide/v0.16.1/full/pyodide.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; function setup_pyodide() { // setup pyodide environment to run code blocks as needed var setup_code = ` import sys, io, traceback namespace = {} # use separate namespace to hide run_code, modules, etc. def run_code(code): \u0026quot;\u0026quot;\u0026quot;run specified code and return stdout and stderr\u0026quot;\u0026quot;\u0026quot; out = io.StringIO() oldout = sys.stdout olderr = sys.stderr sys.stdout = sys.stderr = out try: # change next line to exec(code, {}) if you want to clear vars each time exec(code, namespace) except: traceback.print_exc() sys.stdout = oldout sys.stderr = olderr return out.getvalue() ` pyodide.runPython(setup_code) } function runPython() { // run code currently stored in editor pyodide.globals.code_to_run = editor.getValue() document.getElementById(\u0026quot;output\u0026quot;).value = pyodide.runPython('run_code(code_to_run)') } // run setup_pyodide() when pyodide finishes loading languagePluginLoader.then(setup_pyodide) \u0026lt;/script\u0026gt; 注意他用的是v0.16.1版本pyodide，最新的0.21.3会报错。但是思路很好，贴一下我自己修改的0.21.3版本代码,原理就是把运行的代码当作参数输入预先运行的run_code函数：\n\u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/pyodide/v0.21.3/full/pyodide.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const output = document.getElementById(\u0026quot;output\u0026quot;); const pyplotfigure = document.getElementById(\u0026quot;pyplotfigure\u0026quot;); function addToOutput(s) { output.value += \u0026quot;\u0026gt;\u0026gt;\u0026gt; \u0026quot; + s + \u0026quot;\\n\u0026quot;; } output.value = \u0026quot;Initializing...\\n\u0026quot;; function clearOutput() { output.value = 'Ready!\\n' pyplotfigure.src='' } let pyodide async function runPython() { // run code currently stored in editor let code_to_run = editor.getValue() await pyodide.loadPackagesFromImports(code_to_run); pyodide.globals.set('code_to_run',code_to_run); addToOutput(pyodide.runPython('run_code(code_to_run)')); } async function main(){ pyodide = await loadPyodide(); // await pyodide.loadPackage(['pandas','matplotlib']); var setup_code = ` import sys, io, traceback namespace = {} # use separate namespace to hide run_code, modules, etc. def run_code(_code): \u0026quot;\u0026quot;\u0026quot;run specified code and return stdout and stderr\u0026quot;\u0026quot;\u0026quot; namespace={} _out = io.StringIO() _oldout = sys.stdout _olderr = sys.stderr sys.stdout = sys.stderr = _out try: # change next line to exec(code, {}) if you want to clear vars each time exec(_code,namespace) except: traceback.print_exc() sys.stdout = _oldout sys.stderr = _olderr return _out.getvalue() ` pyodide.runPython(setup_code) output.value += 'Ready!\\n' } main() \u0026lt;/script\u0026gt; 画图显示问题 这下print没问题了，下面解决画图的问题。上面的\nawait pyodide.loadPackagesFromImports(code_to_run); 会自动识别import并导入对应python库的js版本。但是matplotlab画图没法直接出来。我找了两个解决方法\n修改matplotlab的backends，可以把图片输出成canvas在页面中显示 保存图片的base64编码，然后html中的img读取base64编码显示图片 第一个方法参考这个blog，里面提到的这个demo用处很大，直接显示了如何从matplotlab显示图像到网页。\n使用方法就是在运行的python代码里，最前面加上\nimport matplotlib matplotlib.use(\u0026quot;module://matplotlib.backends.html5_canvas_backend\u0026quot;) 指定matplotlab的backend为html5_canvas_backend，就可以生成canvas了，但是有个问题是我不知道如何控制这个canvas的位置，于是使用第二个方法。\n第二个方法参考这个网页，虽然它的pyodide.js链接失效了看不出效果，但是可以修改一下，看到matplotlab作图出现在html上了：\n代码如下：\n\u0026lt;!doctype html\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Demo\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/pyodide/v0.16.1/full/pyodide.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; languagePluginLoader.then(() =\u0026gt; { pyodide.loadPackage(['matplotlib']).then(() =\u0026gt; { pyodide.runPython(` import matplotlib.pyplot as plt import io, base64 fig, ax = plt.subplots() ax.plot([1,3,2]) buf = io.BytesIO() fig.savefig(buf, format='png') buf.seek(0) img_str = 'data:image/png;base64,' + base64.b64encode(buf.read()).decode('UTF-8')` ); document.getElementById(\u0026quot;pyplotfigure\u0026quot;).src=pyodide.globals.img_str });}); \u0026lt;/script\u0026gt; \u0026lt;div id=\u0026quot;textfield\u0026quot;\u0026gt;A matplotlib figure:\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;pyplotdiv\u0026quot;\u0026gt;\u0026lt;img id=\u0026quot;pyplotfigure\u0026quot;/\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;html\u0026gt; 整合 把解决print的方法和第二个输出图片的方法结合起来有点小插曲，一开始修改runPython()\nasync function runPython() { // run code currently stored in editor let code_to_run = editor.getValue() await pyodide.loadPackagesFromImports(code_to_run); pyodide.globals.set('code_to_run',code_to_run); addToOutput(pyodide.runPython('run_code(code_to_run)')); let a = pyodide.globals.get('img_str') if(a){ pyplotfigure.src=a } } 但是let a = pyodide.globals.get('img_str')一开始提示无法找到img_str，后来发现是namespace的锅：\nexec(_code,namespace) 这个会在一个新的namespace里执行，所以在外面找不到里面定义的img_str，改为\nexec(_code,globals()) 使用全局的namespace，就可以看到图片了\n最后代码：\njs：\n\u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/pyodide/v0.21.3/full/pyodide.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const output = document.getElementById(\u0026quot;output\u0026quot;); const pyplotfigure = document.getElementById(\u0026quot;pyplotfigure\u0026quot;); function addToOutput(s) { output.value += \u0026quot;\u0026gt;\u0026gt;\u0026gt; \u0026quot; + s + \u0026quot;\\n\u0026quot;; } output.value = \u0026quot;Initializing...\\n\u0026quot;; function clearOutput() { output.value = 'Ready!\\n' pyplotfigure.src='' } let pyodide async function runPython() { // run code currently stored in editor let code_to_run = editor.getValue() await pyodide.loadPackagesFromImports(code_to_run); pyodide.globals.set('code_to_run',code_to_run); addToOutput(pyodide.runPython('run_code(code_to_run)')); let a = pyodide.globals.get('img_str') if(a){ pyplotfigure.src=a } } async function main(){ pyodide = await loadPyodide(); // await pyodide.loadPackage(['pandas','matplotlib']); var setup_code = ` import sys, io, traceback namespace = {} # use separate namespace to hide run_code, modules, etc. def run_code(_code): \u0026quot;\u0026quot;\u0026quot;run specified code and return stdout and stderr\u0026quot;\u0026quot;\u0026quot; _out = io.StringIO() _oldout = sys.stdout _olderr = sys.stderr sys.stdout = sys.stderr = _out try: # change next line to exec(code, {}) if you want to clear vars each time exec(_code,globals()) except: traceback.print_exc() sys.stdout = _oldout sys.stderr = _olderr return _out.getvalue() ` pyodide.runPython(setup_code) output.value += 'Ready!\\n' } main() \u0026lt;/script\u0026gt; html要加上放图片的地方：\n\u0026lt;div id=\u0026quot;pyplotdiv\u0026quot;\u0026gt;\u0026lt;img id=\u0026quot;pyplotfigure\u0026quot; style=\u0026quot;width: 100% ;\u0026quot;/\u0026gt;\u0026lt;/div\u0026gt; 最后展示一下：\n","date":"2022-10-31T22:19:10+08:00","permalink":"http://blogs.chajiuqqq.cn/p/blockly2python-web-edition%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/","title":"Blockly2python Web Edition开发流程"},{"content":" 原文标题：Strings, bytes, runes and characters in Go\n原文地址：https://go.dev/blog/strings\n译者：z\n介绍 前文介绍了slice如何工作，用一些例子展示了背后实现原理。基于那样的背景下，这篇文章将讨论Go中的strings——字符串。一开始你可能觉得对于一个blog的主题来说字符串太过于简单，但是想要很好地使用它们不仅需要理解它们的工作原理，也要明白byte、character、rune间的区别，unicode和UTF-的区别，字符串和字符串字面值的区别，可能还有其他更细微之处的区别。\n开始这个主题的一个方法是思考这么一个经常被提及的问题：“当我在Go中获取字符串在n位置的东西时，为什么我没有获取到第n个字符？”，正如你所见，这个问题可以让我们思考关于字符串如何工作的更多细节问题。\n一个很棒的，不局限于Go语言的回答是Joel Spolsky的著名blog： The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)。这篇文章会重述他的一些观点。\n什么是字符串 让我们从基础开始吧。\nGo中，一个字符串实际上只是只读的byte slice而已。如果你完全不理解什么是byte的slice或者其工作原理，请读之前这篇blog。这里我们默认你已经读过了。\n首先要声明的很重要的一点是，字符串可以包括任意个数的字节。不一定要包含unicode格式文本、UTF-8格式文本、或其他预定义格式的文本。如果只考虑字符串的内容，它其实就是等同于byte slice。\n这是一个字符串字面值（后面会有更多），它使用\\xNN符号定义一个字符串常量，它会包含各种奇怪的byte（当然，byte范围是从16进制的00到FF，不包括FF）\nconst sample = \u0026quot;\\xbd\\xb2\\x3d\\xbc\\x20\\xe2\\x8c\\x98\u0026quot; 打印字符串 由于举例的字符串中的一些字节是非ASCII字符，甚至不是UTF-8，直接打印字符串会产生不好看的输出，打印语句如下：\nfmt.Println(sample) 会产生这样一堆东西（环境不同显示的东西也不同）\n��=� ⌘ 为了找出字符串到底包含什么，我们需要把它分开，并单独检验每一块。有一些方法可以做到，最明显的就是遍历他的内容，并把每个字节单独输出，看这个for循环：\nfor i := 0; i \u0026lt; len(sample); i++ { fmt.Printf(\u0026quot;%x \u0026quot;, sample[i]) } 如上面展示的，通过索引可以获取到字符串的每个字节，而不是字符。下面我们再细致的看看循环输出的字节：\nbd b2 3d bc 20 e2 8c 98 注意一下每个字节是如何和与字符串中定义的16进制值对应的。\n一个更短的产生可观输出的方法是使用fmt的%X（16进制）格式。它会以16进制输出字符串的字节序列，每个字节是两位：\nfmt.Printf(\u0026quot;%x\\n\u0026quot;, sample) 它的输出是：\nbdb23dbc20e28c98 一个小技巧是在%和x中间添加空格，比较一下区别：\nfmt.Printf(\u0026quot;% x\\n\u0026quot;, sample) 注意下字节间如何打印空格的：\nbd b2 3d bc 20 e2 8c 98 使用%q可以转义输出无法显示的字节，这样输出就会很清晰：\nfmt.Printf(\u0026quot;%q\\n\u0026quot;, sample) 当大多数字符串都很正常而有一些包含了特殊符号需要剔除时，这个方法很方便，它会产生：\n\u0026quot;\\xbd\\xb2=\\xbc ⌘\u0026quot; 如果我们仔细看它，会发现在乱码中有一个ASCII的等号，还有一个正常的空格，最后有个很著名的“Place of Interest” 符号。这个符号的unicode编码是U+2318，在空格（16进制值是20）后面用UTF-8编码：e2 8c 98.\n如果我们不熟悉或被字符串中的奇怪东西绕晕了，我们可以使用+号结合%q。这个组合会输出不可打印的字符的转义格式，以及非ASCII字符的转义格式，这些格式都是UTF-8的. 非ASCII数据会以合适的UTF-8编码打印出来：\nfmt.Printf(\u0026quot;%+q\\n\u0026quot;, sample) 这种格式下，unicode格式的“Place of Interest” 符号会被展示为带\\u转义序列：\n\u0026quot;\\xbd\\xb2=\\xbc \\u2318\u0026quot; 这种打印的方法非常适合字符串内容的debug，下面讨论的时候也会很方便。值得一提的是，所有这些方法应用在字节slice或字符串中时表现一致。\n这是我们提及的所有打印方法，你可以在浏览器中试试运行：\npackage main import \u0026quot;fmt\u0026quot; func main() { const sample = \u0026quot;\\xbd\\xb2\\x3d\\xbc\\x20\\xe2\\x8c\\x98\u0026quot; fmt.Println(\u0026quot;Println:\u0026quot;) fmt.Println(sample) fmt.Println(\u0026quot;Byte loop:\u0026quot;) for i := 0; i \u0026lt; len(sample); i++ { fmt.Printf(\u0026quot;%x \u0026quot;, sample[i]) } fmt.Printf(\u0026quot;\\n\u0026quot;) fmt.Println(\u0026quot;Printf with %x:\u0026quot;) fmt.Printf(\u0026quot;%x\\n\u0026quot;, sample) fmt.Println(\u0026quot;Printf with % x:\u0026quot;) fmt.Printf(\u0026quot;% x\\n\u0026quot;, sample) fmt.Println(\u0026quot;Printf with %q:\u0026quot;) fmt.Printf(\u0026quot;%q\\n\u0026quot;, sample) fmt.Println(\u0026quot;Printf with %+q:\u0026quot;) fmt.Printf(\u0026quot;%+q\\n\u0026quot;, sample) } UTF-8和字符串字面值 如我们所见，索引一个字符串会获得它的字节，而不是字符，一个字符串只是一串的字节而已。这意味着当我们在字符串中存储一个字符时，我们同时存了它的字节表示。让我们看一个更细致的例子：\n这是一个小程序，它按照三种不同的方式打印了只有一个字符的字符串，一种按照字符串打印，一种只打印ASCII字符，一种按照16进制打印每一个字节。为了避免混淆，我们创建了一个原始字符串，由反引号围起来，这样它就只能包含字面值（如果是普通的字符串，由于被双引号包围，可能会包含上面提到的转义序列）\nfunc main() { const placeOfInterest = `⌘` fmt.Printf(\u0026quot;plain string: \u0026quot;) fmt.Printf(\u0026quot;%s\u0026quot;, placeOfInterest) fmt.Printf(\u0026quot;\\n\u0026quot;) fmt.Printf(\u0026quot;quoted string: \u0026quot;) fmt.Printf(\u0026quot;%+q\u0026quot;, placeOfInterest) fmt.Printf(\u0026quot;\\n\u0026quot;) fmt.Printf(\u0026quot;hex bytes: \u0026quot;) for i := 0; i \u0026lt; len(placeOfInterest); i++ { fmt.Printf(\u0026quot;%x \u0026quot;, placeOfInterest[i]) } fmt.Printf(\u0026quot;\\n\u0026quot;) } 输出是：\nplain string: ⌘ quoted string: \u0026quot;\\u2318\u0026quot; hex bytes: e2 8c 98 这提醒了我们U+2318是“Place of Interest” 符号 ⌘的unicode编号，并且由字节表示为e2 8c 98，这些字节是16进制数2318按照UTF-8编码后的字节表示。\n依赖于你对UTF-8的熟悉程度，你可能很清楚这些或者有点模糊，但是花点时间解释一下UTF-8是如何表示我们创建的字符串是很有必要的。最简单的事实是：当源码写入时，它就创建出来了。\n源码在Go中被定义为UTF-8文本，并且不允许其他格式的表示。这意味着在源码中，当我们输入： ⌘ 时，文本编辑器会把⌘符号的UTF-8编码存入源码中，当我们输出16进制字节时，我们只是复制输出了文件中编辑器放入的数据。\n更精简点来说，Go语言源码是UTF-8，所以字符串字面量的源码就是UTF-8文本。如果字符串字面值不包含转义序列（反引号构建的原始字符串不能包含转义字符），构造出来的字符串引号中间的文本就是源码文本。因此原始字符串总是会包含合法的UTF-8文本。类似的，普通字符串经常由合法的UTF-8文本组成，除非它包含上面提到的不在UTF-8编码中的转义序列。\n译注：\n反引号 `` 组成的字符串不会进行转义处理，所以字符串内容=存入的源码\n普通字符串 \u0026quot;\u0026quot; 会进行转义处理，比如\\x2b会识别成一个16进制数据存入，而不是存入\\、x、2、b。如果这个16进制数不在UTF-8编码中，那就是非法的UTF-8编码，无法被打印出来。\n一些人认为Go字符串总是UTF-8编码，其实不是：只有字符串字面值是UTF-8编码.正如我们上面提到的，字符串值可以包含任意的字节；字符串字面值只要没有字节等级的转义就总是UTF-8文本。\n总结来说，字符串可以包含任意字节，但是从字面值构建时，这些字节通常都是UTF-8编码的。\nCode points、字符、runes 目前为止我们都很小心地使用单词“字节”和“字符”。一部分原因是因为字符串包含字节，另一部分是因为字符这个概念有点难以定义。Unicode标准使用“Code point”定义单一值表示的东西，比如Code points U+2318，16进制值2318，代表了⌘符号（更多Code point参考Unicode page）\n一个更普通地例子是Unicode Code point U+0061是小写字母：a\n但是小写重音字母à如何表示？这是一个字符，也是Code point U+00E0，但是它有其他表示方法。比如我们可以结合重音Code point，U+0300，附加到小写字母a，U+0061上，构建出同样的字符à。通常来说一个字符可以被多种不同的Code point组合表示，因此有不同的UTF-8字节序列。\n因此计算机的字符概念是模糊的，或者容易混淆，所以我们要小心使用。为了让他更可靠，有一些标准化技术可以保证一个字符只有一种Code point的表示方式，但是这个主题不在我们讨论的范围内，之后会有一个新的blog介绍Go库是如何处理标准化的。\n“Code point”有点绕口，为此在Go中有个更短的术语：rune。这个术语会在库和源码中出现，和Code point意思相同，但有一个新的特点。\nGo语言中rune是类型int32的别名，所以程序可以理解一个int类型的数值表示为Code point的状况。除此以外，一个字符常量在Go中其实被称为一个rune常量。\n'⌘' 这个符号的类型是rune，值是整型的0x2318.\n总的来说，这是几个重点：\nGo源码总是UTF-8的 一个字符串可以包含任意字节 一个字符串字面值如果没有字节层面的转义，那就是合法的UTF-8序列。 这些序列代表了unicode的Code point，也就是rune。 无法保证Go中字符串的字符是标准化过的。 for range循环 除了不言自明的一个细节——go源码是UTF-8编码的，只有在一种情况下，go会特殊处理UTF-8编码，那就是当你对字符串使用for range循环的时候。\n我们知道普通的for循环会发生什么，对于for range循环，每次遍历时都会解码一个UTF-8的rune。每次循环时，下标是当前rune的开始位置，测量单位是字节，code point就是他的值。这个例子使用了另一个打印格式%#U，可以打印unicode编码和代表的字符：\nconst nihongo = \u0026quot;日本語\u0026quot; for index, runeValue := range nihongo { fmt.Printf(\u0026quot;%#U starts at byte position %d\\n\u0026quot;, runeValue, index) } 输出会显示每个code point占据了多个字节：\nU+65E5 '日' starts at byte position 0 U+672C '本' starts at byte position 3 U+8A9E '語' starts at byte position 6 标准库 Go的标准库对解释UTF-8文本提供了强大支持。如果for range循环对你来说不够用，那么可以试试库里的包。\n最重要的包是unicode/utf8，提供了UTF-8字符串的验证、拆分、组装方法。这个程序等同于上面的for range循环，但是使用了DecodeRuneInString方法实现。返回值是rune和他的UTF-8编码字节个数。\nconst nihongo = \u0026quot;日本語\u0026quot; for i, w := 0, 0; i \u0026lt; len(nihongo); i += w { runeValue, width := utf8.DecodeRuneInString(nihongo[i:]) fmt.Printf(\u0026quot;%#U starts at byte position %d\\n\u0026quot;, runeValue, i) w = width } 运行可以看到结果相同。for range循环和DecodeRuneInString 方法会产生相同的迭代结果。\n这个包的其他方法请查看unicode/utf8文档\n结论 回答一下文章开始提出的问题：字符串由字节组成，因此索引字符串会获得字节，而不是字符。一个字符串甚至可能不包含字符。实际上“字符”的定义就是模糊的，如果你把字符串定义为由字符组成，你可能会遇到一些模糊性问题。\n还有很多关于unicode，UTF-8和多语言文本处理的东西可以讲，但是请等下一个blog吧，现在我希望你更理解Go的字符串如何呈现的了，即使它们可能包含任意的字节，它的核心设计的一部分仍旧是UTF-8编码.\n","date":"2022-10-07T12:16:11+08:00","permalink":"http://blogs.chajiuqqq.cn/p/golang%E4%B8%AD%E7%9A%84strings-bytes-runes%E5%92%8Ccharacters/","title":"GoLang中的Strings, bytes, runes和characters"},{"content":"Cloudflare Tunnel可以实现通过域名访问本地暴露的服务功能，类似frp做的隧道，但是不用自己搭建服务端，只要配置好客户端即可。doc link\n下面说一下配置方式。\n1、Dashboard创建tunnel 首先给出官方教程，熟悉英文的可以直接看 link\n去到 Zero Trust dashboard，在Access \u0026gt; Tunnels创建tunnel。\n先取个名字 public hostname 里添加自定义subdomain，domain选择在cloudflare绑定过的域名。 如果cloudflare没有创建过website，在这里创建。需要自行申请一个域名，推荐freenom，然后修改域名nameserver为cloudflare的，这样这个域名就可以由cloudflare管理了。\nservice选择你要的服务，一般是http，然后地址一般是写127.0.0.1+本地服务端口号，如127.0.0.1:5000。保存后这个website自动添加dns解析到你的本地机器。 这里不再需要去域名dns处手动添加了，他自动添加好了\n2、运行cloudflared客户端 我使用的是群晖nas+docker版，主要是图形化的docker怎么运行cloudflared。\n下载docker套件 在注册表里搜索cloudflared并下载 开启容器，需要配置两个地方 环境变量添加TUNNEL_TRANSPORT_PROTOCOL，值为http2，因为默认的quic协议国内不支持，需要改成http2 下方命令输入创建tunnel时docker下的提示部分，如docker run cloudflare/cloudflared:latest tunnel --no-autoupdate run --token eyJhIjoiZjYyMDUyMjxxxxx你就复制tunnel --no-autoupdate run --token eyJhIjoiZjYyMDUyMjxxxxx进去 Zero Trust dashboard的tunnel里看到active就说明连上了 3、访问subdomin就会代理到你本地的服务 如我的nas域名设置了https://nas.ipppz.tk/，并转发到nas的5000端口，接下来就直接用域名访问即可，也是支持https的。\n","date":"2022-10-01T13:31:05+08:00","permalink":"http://blogs.chajiuqqq.cn/p/%E4%BD%BF%E7%94%A8cloudflare-tunnel%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2/","title":"使用Cloudflare Tunnel实现本地服务暴露"},{"content":"应该算是第一篇比较正式的blog吧，前几天把bolg搭起来了，今天又实现了持续集成，可以实现一个仓库保存blogs和网站页面，并在更新的时候自动构建+部署网站。这种构建方式最大的好处是免费+资料掌握+自动部署，那下面就来介绍一下怎么实现。\n使用流程 在多台设备上可clone一个仓库，使用hugo或手动在content/post下新建md文件攥写文章，完成后git提交并推送远程仓库，远程仓库会自动构建网站，用户等一会就可以看到网站更新了。\n编写环境只要有git即可完成编写+部署流程（当然添加了hugo在创建文章时会更方便啦，而且可以本地看到效果）。\n搭建逻辑 博客可以是静态的，也可以是动态的。静态的就是一堆由HTML和CSS、JS组成的文件直接被浏览器访问，没有后台程序提供业务支持，好处是不吃资源，访问只受网络带宽限制，坏处是没法做业务处理了；\n动态指的是由前端+后端组合支持的网站，好处是可以做自由的业务和管理，坏处是部署麻烦，对资源需求大，并发访问受到服务器性能限制。\n为了便于维护，本文搭建的是静态网站。\n采用技术是\nMarkdown：文章编写语法 Hugo：静态网站编译工具 GitHub Page：网页托管 GitHub Action：自动构建服务 Hugo的使用逻辑是，我们编写markdown格式文章，并附加某种格式的数据，写好后交给Hugo工具“构建”生成静态的HTML和CSS、JS组成的文件，这些文件统一放在public文件夹下，此时部署public就可以看到你的网站了。\n其中一个缺点是每次需要Hugo的环境来“构建”，并需要维护两套代码：文章源代码和网站代码\n当结合Github Action时，可以把这个构建过程交给云端处理。每次主分支推送时都会触发这个“构建”，同时把public下的文件推送到gh-page分支，利用Github Page挂载你的网站，这样网站就更新好并可以浏览了。\n搭建步骤 1、安装hugo Hugo没有一键安装包，可以使用包管理工具安装，MacOS用brew，Windows用chocolatey。各个系统安装看这\n1 2 3 4 5 MacOS: brew install hugo Windows: choco install hugo -confirm 安装完成后使用hugo new site quickstart创建quickstart文件夹作为网站主目录。\n进入目录，使用hugo new posts/my-first-post.md创建一个新的文章。然后把draft: true删除或者改为draft: false，这样就公开文章咯。\n使用hugo server可以在本地部署网站，访问 http://localhost:1313/ 就可以看到网站咯！\n更多Hugo使用教程参考这个。\n2、添加Github Action 官方文档里有说明,这里概述一下：\n在你的项目下创建.github/workflows/gh-pages.yml这个路径的文件 复制这一段进去,注意下面两个main的地方，如果你用master，则改成master 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 name: github pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 3、添加仓库 初始化好网站后，使用git初始化仓库，并提交。\n1 2 3 git init git add . git commit -m \u0026#34;init\u0026#34; 在github上创建新仓库，这个仓库名称可以是用户名.github.io，或者别的。最后访问地址是用户名.github.io或者用户名.github.io/仓库名.不需要readme。然后本地仓库添加远程仓库，并推送。\n推送成功后，Action会自动build网站并推送到gh-pages分支。因此我们使用一个仓库的不同分支来管理文章源代码和网站代码。\n3、设置GitHub Page 在项目设置里选择Pages，初次构建需要指定哪个分支的代码用作Page，选择gh-pages分支并保存即可，上方会给出可以访问的地址。我的仓库名称是blogs，因此地址是 https://chajiuqqq.github.io/blogs/ ，试试访问你的网站，应该可以看到第一篇文章咯。\n如果看得到网站，但是文章点不进去，请修改config.yaml，将baseurl换成你的网站地址即可！这是线上部署网站必要的步骤！\n如：\n1 baseurl: https://chajiuqqq.github.io/blogs/ 如果没有config.yaml咋办？把原来的config.xxx删了，自己创建config.yaml即可！hugo会识别到这个配置文件哦！\n5、再发布一篇新文章 进入网站目录，新建文章\n1 hugo new posts/second-post.md 在vscode或其他markdown编辑器中编写文章，记得把draft取消哦\ngit提交并推送\n等待网站自动构建\n访问网站\n是不是很方便呢\n最后 hugo提供了很多好看的主题，参考主题指南进行更换哦，比如我使用的hugo-theme-stack\n配置方法就是在网站目录下添加这个库\n1 git submodule add https://github.com/CaiJimmy/hugo-theme-stack themes/hugo-theme-stack 并修改config.yaml，这个可以直接复制hugo-theme-stack下examplesite的config.yaml再修改哦。最主要的就是baseurl换成你的网站地址即可！下面贴上我的配置.\nThe End\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 baseurl: https://chajiuqqq.github.io/blogs/ languageCode: en-us theme: hugo-theme-stack paginate: 5 title: 茶酒的小站 languages: en: languageName: English title: Chajiu\u0026#39;s blog weight: 1 zh-cn: languageName: 中文 title: 茶酒的小站 weight: 2 ar: languageName: عربي languagedirection: rtl title: موقع تجريبي weight: 3 # Change it to your Disqus shortname before using disqusShortname: hugo-theme-stack # GA Tracking ID googleAnalytics: # Theme i18n support # Available values: ar, bn, ca, de, el, en, es, fr, hu, id, it, ja, ko, nl, pt-br, th, uk, zh-cn, zh-hk, zh-tw DefaultContentLanguage: zh-cn # Set hasCJKLanguage to true if DefaultContentLanguage is in [zh-cn ja ko] # This will make .Summary and .WordCount behave correctly for CJK languages. hasCJKLanguage: true permalinks: post: /p/:slug/ page: /:slug/ params: mainSections: - post featuredImageField: image rssFullContent: true favicon: footer: since: 2020 customText: dateFormat: published: Jan 02, 2006 lastUpdated: Jan 02, 2006 15:04 MST sidebar: emoji: 🍥 subtitle: 一个年轻的小站 avatar: enabled: true local: true src: img/avatar.jpeg article: math: false toc: true readingTime: true license: enabled: true default: Licensed under CC BY-NC-SA 4.0 comments: enabled: true provider: disqus disqusjs: shortname: apiUrl: apiKey: admin: adminLabel: utterances: repo: issueTerm: pathname label: remark42: host: site: locale: vssue: platform: owner: repo: clientId: clientSecret: autoCreateIssue: false # Waline client configuration see: https://waline.js.org/en/reference/component.html waline: serverURL: lang: pageview: emoji: - https://unpkg.com/@waline/emojis@1.0.1/weibo requiredMeta: - name - email - url locale: admin: Admin placeholder: twikoo: envId: region: path: lang: # See https://cactus.chat/docs/reference/web-client/#configuration for description of the various options cactus: defaultHomeserverUrl: \u0026#34;https://matrix.cactus.chat:8448\u0026#34; serverName: \u0026#34;cactus.chat\u0026#34; siteName: \u0026#34;\u0026#34; # You must insert a unique identifier here matching the one you registered (See https://cactus.chat/docs/getting-started/quick-start/#register-your-site) giscus: repo: repoID: category: categoryID: mapping: lightTheme: darkTheme: reactionsEnabled: 1 emitMetadata: 0 gitalk: owner: admin: repo: clientID: clientSecret: cusdis: host: id: widgets: homepage: - type: search - type: archives params: limit: 5 - type: categories params: limit: 10 - type: tag-cloud params: limit: 10 page: - type: toc opengraph: twitter: # Your Twitter username site: # Available values: summary, summary_large_image card: summary_large_image defaultImage: opengraph: enabled: false local: false src: colorScheme: # Display toggle toggle: true # Available values: auto, light, dark default: auto imageProcessing: cover: enabled: true content: enabled: true ### Custom menu ### See https://docs.stack.jimmycai.com/configuration/custom-menu.html ### To remove about, archive and search page menu item, remove `menu` field from their FrontMatter menu: main: [] social: - identifier: github name: GitHub url: https://github.com/chajiuqqq params: icon: brand-github - identifier: twitter name: Twitter url: https://twitter.com params: icon: brand-twitter related: includeNewer: true threshold: 60 toLower: false indices: - name: tags weight: 100 - name: categories weight: 200 markup: goldmark: renderer: ## Set to true if you have HTML content inside Markdown unsafe: false tableOfContents: endLevel: 4 ordered: true startLevel: 2 highlight: noClasses: false codeFences: true guessSyntax: true lineNoStart: 1 lineNos: true lineNumbersInTable: true tabWidth: 4 ","date":"2022-08-24T16:32:10+08:00","permalink":"http://blogs.chajiuqqq.cn/p/hugo--gitpages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/","title":"Hugo + GitPages博客搭建指南"},{"content":"正文 你好，测试\n这是2朵美丽的花：\n竖排：\n第二段 会议\n","date":"2022-08-18T15:20:49+08:00","image":"http://blogs.chajiuqqq.cn/p/say-hello/butterfly-7353884_1920_hue396b29070a692a4e28129944f8b6538_270095_120x120_fill_q75_box_smart1.jpeg","permalink":"http://blogs.chajiuqqq.cn/p/say-hello/","title":"Say Hello"}]