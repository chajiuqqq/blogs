[{"content":" 原文标题：Strings, bytes, runes and characters in Go\n原文地址：https://go.dev/blog/strings\n译者：z\n介绍 前文介绍了slice如何工作，用一些例子展示了背后实现原理。基于那样的背景下，这篇文章将讨论Go中的strings——字符串。一开始你可能觉得对于一个blog的主题来说字符串太过于简单，但是想要很好地使用它们不仅需要理解它们的工作原理，也要明白byte、character、rune间的区别，unicode和UTF-的区别，字符串和字符串字面值的区别，可能还有其他更细微之处的区别。\n开始这个主题的一个方法是思考这么一个经常被提及的问题：“当我在Go中获取字符串在n位置的东西时，为什么我没有获取到第n个字符？”，正如你所见，这个问题可以让我们思考关于字符串如何工作的更多细节问题。\n一个很棒的，不局限于Go语言的回答是Joel Spolsky的著名blog： The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)。这篇文章会重述他的一些观点。\n什么是字符串 让我们从基础开始吧。\nGo中，一个字符串实际上只是只读的byte slice而已。如果你完全不理解什么是byte的slice或者其工作原理，请读之前这篇blog。这里我们默认你已经读过了。\n首先要声明的很重要的一点是，字符串可以包括任意个数的字节。不一定要包含unicode格式文本、UTF-8格式文本、或其他预定义格式的文本。如果只考虑字符串的内容，它其实就是等同于byte slice。\n这是一个字符串字面值（后面会有更多），它使用\\xNN符号定义一个字符串常量，它会包含各种奇怪的byte（当然，byte范围是从16进制的00到FF，不包括FF）\nconst sample = \u0026quot;\\xbd\\xb2\\x3d\\xbc\\x20\\xe2\\x8c\\x98\u0026quot; 打印字符串 由于举例的字符串中的一些字节是非ASCII字符，甚至不是UTF-8，直接打印字符串会产生不好看的输出，打印语句如下： fmt.Println(sample)\n会产生这样一堆东西（环境不同显示的东西也不同）\n��=� ⌘ 为了找出字符串到底包含什么，我们需要把它分开，并单独检验每一块。有一些方法可以做到，最明显的就是遍历他的内容，并把每个字节单独输出，看这个for循环： for i := 0; i \u0026lt; len(sample); i++ { fmt.Printf(\u0026quot;%x \u0026ldquo;, sample[i]) }\n如上面展示的，通过索引可以获取到字符串的每个字节，而不是字符。下面我们再细致的看看循环输出的字节：\nbd b2 3d bc 20 e2 8c 98 注意一下每个字节是如何和与字符串中定义的16进制值对应的。\n一个更短的产生可观输出的方法是使用fmt的%X（16进制）格式。它会以16进制输出字符串的字节序列，每个字节是两位： fmt.Printf(\u0026quot;%x\\n\u0026rdquo;, sample)\n它的输出是： bdb23dbc20e28c98\n一个小技巧是在%和x中间添加空格，比较一下区别： fmt.Printf(\u0026quot;% x\\n\u0026quot;, sample)\n注意下字节间如何打印空格的：\nbd b2 3d bc 20 e2 8c 98 使用%q可以转义输出无法显示的字节，这样输出就会很清晰：\nfmt.Printf(\u0026quot;%q\\n\u0026quot;, sample) 当大多数字符串都很正常而有一些包含了特殊符号需要剔除时，这个方法很方便，它会产生：\n\u0026quot;\\xbd\\xb2=\\xbc ⌘\u0026quot; 如果我们仔细看它，会发现在乱码中有一个ASCII的等号，还有一个正常的空格，最后有个很著名的“Place of Interest” 符号。这个符号的unicode编码是U+2318，在空格（16进制值是20）后面用UTF-8编码：e2 8c 98.\n如果我们不熟悉或被字符串中的奇怪东西绕晕了，我们可以使用+号结合%q。这个组合会输出不可打印的字符的转义格式，以及非ASCII字符的转义格式，这些格式都是UTF-8的. 非ASCII数据会以合适的UTF-8编码打印出来：\nfmt.Printf(\u0026quot;%+q\\n\u0026quot;, sample) 这种格式下，unicode格式的“Place of Interest” 符号会被展示为带\\u转义序列：\n\u0026quot;\\xbd\\xb2=\\xbc \\u2318\u0026quot; 这种打印的方法非常适合字符串内容的debug，下面讨论的时候也会很方便。值得一提的是，所有这些方法应用在字节slice或字符串中时表现一致。\n这是我们提及的所有打印方法，你可以在浏览器中试试运行：\npackage main import \u0026quot;fmt\u0026quot; func main() { const sample = \u0026quot;\\xbd\\xb2\\x3d\\xbc\\x20\\xe2\\x8c\\x98\u0026quot; fmt.Println(\u0026quot;Println:\u0026quot;) fmt.Println(sample) fmt.Println(\u0026quot;Byte loop:\u0026quot;) for i := 0; i \u0026lt; len(sample); i++ { fmt.Printf(\u0026quot;%x \u0026quot;, sample[i]) } fmt.Printf(\u0026quot;\\n\u0026quot;) fmt.Println(\u0026quot;Printf with %x:\u0026quot;) fmt.Printf(\u0026quot;%x\\n\u0026quot;, sample) fmt.Println(\u0026quot;Printf with % x:\u0026quot;) fmt.Printf(\u0026quot;% x\\n\u0026quot;, sample) fmt.Println(\u0026quot;Printf with %q:\u0026quot;) fmt.Printf(\u0026quot;%q\\n\u0026quot;, sample) fmt.Println(\u0026quot;Printf with %+q:\u0026quot;) fmt.Printf(\u0026quot;%+q\\n\u0026quot;, sample) } UTF-8和字符串字面值 如我们所见，索引一个字符串会获得它的字节，而不是字符，一个字符串只是一串的字节而已。这意味着当我们在字符串中存储一个字符时，我们同时存了它的字节表示。让我们看一个更细致的例子：\n这是一个小程序，它按照三种不同的方式打印了只有一个字符的字符串，一种按照字符串打印，一种只打印ASCII字符，一种按照16进制打印每一个字节。为了避免混淆，我们创建了一个原始字符串，由反引号围起来，这样它就只能包含字面值（如果是普通的字符串，由于被双引号包围，可能会包含上面提到的转义序列）\nfunc main() { const placeOfInterest = `⌘` fmt.Printf(\u0026quot;plain string: \u0026quot;) fmt.Printf(\u0026quot;%s\u0026quot;, placeOfInterest) fmt.Printf(\u0026quot;\\n\u0026quot;) fmt.Printf(\u0026quot;quoted string: \u0026quot;) fmt.Printf(\u0026quot;%+q\u0026quot;, placeOfInterest) fmt.Printf(\u0026quot;\\n\u0026quot;) fmt.Printf(\u0026quot;hex bytes: \u0026quot;) for i := 0; i \u0026lt; len(placeOfInterest); i++ { fmt.Printf(\u0026quot;%x \u0026quot;, placeOfInterest[i]) } fmt.Printf(\u0026quot;\\n\u0026quot;) } 输出是：\nplain string: ⌘ quoted string: \u0026quot;\\u2318\u0026quot; hex bytes: e2 8c 98 这提醒了我们U+2318是“Place of Interest” 符号 ⌘的unicode编号，并且由字节表示为e2 8c 98，这些字节是16进制数2318按照UTF-8编码后的字节表示。\n依赖于你对UTF-8的熟悉程度，你可能很清楚这些或者有点模糊，但是花点时间解释一下UTF-8是如何表示我们创建的字符串是很有必要的。最简单的事实是：当源码写入时，它就创建出来了。\n源码在Go中被定义为UTF-8文本，并且不允许其他格式的表示。这意味着在源码中，当我们输入： ⌘ 时，文本编辑器会把⌘符号的UTF-8编码存入源码中，当我们输出16进制字节时，我们只是复制输出了文件中编辑器放入的数据。\n更精简点来说，Go语言源码是UTF-8，所以字符串字面量的源码就是UTF-8文本。如果字符串字面值不包含转义序列（反引号构建的原始字符串不能包含转义字符），构造出来的字符串引号中间的文本就是源码文本。因此原始字符串总是会包含合法的UTF-8文本。类似的，普通字符串经常由合法的UTF-8文本组成，除非它包含上面提到的不在UTF-8编码中的转义序列。\n译注：\n反引号 `` 组成的字符串不会进行转义处理，所以字符串内容=存入的源码\n普通字符串 \u0026quot;\u0026quot; 会进行转义处理，比如\\x2b会识别成一个16进制数据存入，而不是存入\\、x、2、b。如果这个16进制数不在UTF-8编码中，那就是非法的UTF-8编码，无法被打印出来。\n一些人认为Go字符串总是UTF-8编码，其实不是：只有字符串字面值是UTF-8编码.正如我们上面提到的，字符串值可以包含任意的字节；字符串字面值只要没有字节等级的转义就总是UTF-8文本。\n总结来说，字符串可以包含任意字节，但是从字面值构建时，这些字节通常都是UTF-8编码的。\nCode points、字符、runes 目前为止我们都很小心地使用单词“字节”和“字符”。一部分原因是因为字符串包含字节，另一部分是因为字符这个概念有点难以定义。Unicode标准使用“Code point”定义单一值表示的东西，比如Code points U+2318，16进制值2318，代表了⌘符号（更多Code point参考Unicode page）\n一个更普通地例子是Unicode Code point U+0061是小写字母：a\n但是小写重音字母à如何表示？这是一个字符，也是Code point U+00E0，但是它有其他表示方法。比如我们可以结合重音Code point，U+0300，附加到小写字母a，U+0061上，构建出同样的字符à。通常来说一个字符可以被多种不同的Code point组合表示，因此有不同的UTF-8字节序列。\n因此计算机的字符概念是模糊的，或者容易混淆，所以我们要小心使用。为了让他更可靠，有一些标准化技术可以保证一个字符只有一种Code point的表示方式，但是这个主题不在我们讨论的范围内，之后会有一个新的blog介绍Go库是如何处理标准化的。\n“Code point”有点绕口，为此在Go中有个更短的术语：rune。这个术语会在库和源码中出现，和Code point意思相同，但有一个新的特点。\nGo语言中rune是类型int32的别名，所以程序可以理解一个int类型的数值表示为Code point的状况。除此以外，一个字符常量在Go中其实被称为一个rune常量。\n'⌘' 这个符号的类型是rune，值是整型的0x2318.\n总的来说，这是几个重点：\nGo源码总是UTF-8的 一个字符串可以包含任意字节 一个字符串字面值如果没有字节层面的转义，那就是合法的UTF-8序列。 这些序列代表了unicode的Code point，也就是rune。 无法保证Go中字符串的字符是标准化过的。 for range循环 除了不言自明的一个细节——go源码是UTF-8编码的，只有在一种情况下，go会特殊处理UTF-8编码，那就是当你对字符串使用for range循环的时候。\n我们知道普通的for循环会发生什么，对于for range循环，每次遍历时都会解码一个UTF-8的rune。每次循环时，下标是当前rune的开始位置，测量单位是字节，code point就是他的值。这个例子使用了另一个打印格式%#U，可以打印unicode编码和代表的字符：\nconst nihongo = \u0026quot;日本語\u0026quot; for index, runeValue := range nihongo { fmt.Printf(\u0026quot;%#U starts at byte position %d\\n\u0026quot;, runeValue, index) } 输出会显示每个code point占据了多个字节：\nU+65E5 '日' starts at byte position 0 U+672C '本' starts at byte position 3 U+8A9E '語' starts at byte position 6 标准库 Go的标准库对解释UTF-8文本提供了强大支持。如果for range循环对你来说不够用，那么可以试试库里的包。\n最重要的包是unicode/utf8，提供了UTF-8字符串的验证、拆分、组装方法。这个程序等同于上面的for range循环，但是使用了DecodeRuneInString方法实现。返回值是rune和他的UTF-8编码字节个数。\nconst nihongo = \u0026quot;日本語\u0026quot; for i, w := 0, 0; i \u0026lt; len(nihongo); i += w { runeValue, width := utf8.DecodeRuneInString(nihongo[i:]) fmt.Printf(\u0026quot;%#U starts at byte position %d\\n\u0026quot;, runeValue, i) w = width } 运行可以看到结果相同。for range循环和DecodeRuneInString 方法会产生相同的迭代结果。\n这个包的其他方法请查看unicode/utf8文档\n结论 回答一下文章开始提出的问题：字符串由字节组成，因此索引字符串会获得字节，而不是字符。一个字符串甚至可能不包含字符。实际上“字符”的定义就是模糊的，如果你把字符串定义为由字符组成，你可能会遇到一些模糊性问题。\n还有很多关于unicode，UTF-8和多语言文本处理的东西可以讲，但是请等下一个blog吧，现在我希望你更理解Go的字符串如何呈现的了，即使它们可能包含任意的字节，它的核心设计的一部分仍旧是UTF-8编码.\n","date":"2022-10-07T12:16:11+08:00","permalink":"https://chajiuqqq.github.io/blogs/p/golang%E4%B8%AD%E7%9A%84strings-bytes-runes%E5%92%8Ccharacters/","title":"GoLang中的Strings, bytes, runes和characters"},{"content":"Cloudflare Tunnel可以实现通过域名访问本地暴露的服务功能，类似frp做的隧道，但是不用自己搭建服务端，只要配置好客户端即可。doc link\n下面说一下配置方式。\n1、Dashboard创建tunnel 首先给出官方教程，熟悉英文的可以直接看 link\n去到 Zero Trust dashboard，在Access \u0026gt; Tunnels创建tunnel。\n先取个名字 public hostname 里添加自定义subdomain，domain选择在cloudflare绑定过的域名。 如果cloudflare没有创建过website，在这里创建。需要自行申请一个域名，推荐freenom，然后修改域名nameserver为cloudflare的，这样这个域名就可以由cloudflare管理了。\nservice选择你要的服务，一般是http，然后地址一般是写127.0.0.1+本地服务端口号，如127.0.0.1:5000。保存后这个website自动添加dns解析到你的本地机器。 这里不再需要去域名dns处手动添加了，他自动添加好了\n2、运行cloudflared客户端 我使用的是群晖nas+docker版，主要是图形化的docker怎么运行cloudflared。\n下载docker套件 在注册表里搜索cloudflared并下载 开启容器，需要配置两个地方 环境变量添加TUNNEL_TRANSPORT_PROTOCOL，值为http2，因为默认的quic协议国内不支持，需要改成http2 下方命令输入创建tunnel时docker下的提示部分，如docker run cloudflare/cloudflared:latest tunnel --no-autoupdate run --token eyJhIjoiZjYyMDUyMjxxxxx你就复制tunnel --no-autoupdate run --token eyJhIjoiZjYyMDUyMjxxxxx进去 Zero Trust dashboard的tunnel里看到active就说明连上了 3、访问subdomin就会代理到你本地的服务 如我的nas域名设置了https://nas.ipppz.tk/，并转发到nas的5000端口，接下来就直接用域名访问即可，也是支持https的。\n","date":"2022-10-01T13:31:05+08:00","permalink":"https://chajiuqqq.github.io/blogs/p/%E4%BD%BF%E7%94%A8cloudflare-tunnel%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2/","title":"使用Cloudflare Tunnel实现本地服务暴露"},{"content":"应该算是第一篇比较正式的blog吧，前几天把bolg搭起来了，今天又实现了持续集成，可以实现一个仓库保存blogs和网站页面，并在更新的时候自动构建+部署网站。这种构建方式最大的好处是免费+资料掌握+自动部署，那下面就来介绍一下怎么实现。\n使用流程 在多台设备上可clone一个仓库，使用hugo或手动在content/post下新建md文件攥写文章，完成后git提交并推送远程仓库，远程仓库会自动构建网站，用户等一会就可以看到网站更新了。\n编写环境只要有git即可完成编写+部署流程（当然添加了hugo在创建文章时会更方便啦，而且可以本地看到效果）。\n搭建逻辑 博客可以是静态的，也可以是动态的。静态的就是一堆由HTML和CSS、JS组成的文件直接被浏览器访问，没有后台程序提供业务支持，好处是不吃资源，访问只受网络带宽限制，坏处是没法做业务处理了；\n动态指的是由前端+后端组合支持的网站，好处是可以做自由的业务和管理，坏处是部署麻烦，对资源需求大，并发访问受到服务器性能限制。\n为了便于维护，本文搭建的是静态网站。\n采用技术是\nMarkdown：文章编写语法 Hugo：静态网站编译工具 GitHub Page：网页托管 GitHub Action：自动构建服务 Hugo的使用逻辑是，我们编写markdown格式文章，并附加某种格式的数据，写好后交给Hugo工具“构建”生成静态的HTML和CSS、JS组成的文件，这些文件统一放在public文件夹下，此时部署public就可以看到你的网站了。\n其中一个缺点是每次需要Hugo的环境来“构建”，并需要维护两套代码：文章源代码和网站代码\n当结合Github Action时，可以把这个构建过程交给云端处理。每次主分支推送时都会触发这个“构建”，同时把public下的文件推送到gh-page分支，利用Github Page挂载你的网站，这样网站就更新好并可以浏览了。\n搭建步骤 1、安装hugo Hugo没有一键安装包，可以使用包管理工具安装，MacOS用brew，Windows用chocolatey。各个系统安装看这\n1 2 3 4 5 MacOS: brew install hugo Windows: choco install hugo -confirm 安装完成后使用hugo new site quickstart创建quickstart文件夹作为网站主目录。\n进入目录，使用hugo new posts/my-first-post.md创建一个新的文章。然后把draft: true删除或者改为draft: false，这样就公开文章咯。\n使用hugo server可以在本地部署网站，访问 http://localhost:1313/ 就可以看到网站咯！\n更多Hugo使用教程参考这个。\n2、添加Github Action 官方文档里有说明,这里概述一下：\n在你的项目下创建.github/workflows/gh-pages.yml这个路径的文件 复制这一段进去,注意下面两个main的地方，如果你用master，则改成master 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 name: github pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 3、添加仓库 初始化好网站后，使用git初始化仓库，并提交。\n1 2 3 git init git add . git commit -m \u0026#34;init\u0026#34; 在github上创建新仓库，这个仓库名称可以是用户名.github.io，或者别的。最后访问地址是用户名.github.io或者用户名.github.io/仓库名.不需要readme。然后本地仓库添加远程仓库，并推送。\n推送成功后，Action会自动build网站并推送到gh-pages分支。因此我们使用一个仓库的不同分支来管理文章源代码和网站代码。\n3、设置GitHub Page 在项目设置里选择Pages，初次构建需要指定哪个分支的代码用作Page，选择gh-pages分支并保存即可，上方会给出可以访问的地址。我的仓库名称是blogs，因此地址是 https://chajiuqqq.github.io/blogs/ ，试试访问你的网站，应该可以看到第一篇文章咯。\n如果看得到网站，但是文章点不进去，请修改config.yaml，将baseurl换成你的网站地址即可！这是线上部署网站必要的步骤！\n如：\n1 baseurl: https://chajiuqqq.github.io/blogs/ 如果没有config.yaml咋办？把原来的config.xxx删了，自己创建config.yaml即可！hugo会识别到这个配置文件哦！\n5、再发布一篇新文章 进入网站目录，新建文章\n1 hugo new posts/second-post.md 在vscode或其他markdown编辑器中编写文章，记得把draft取消哦\ngit提交并推送\n等待网站自动构建\n访问网站\n是不是很方便呢\n最后 hugo提供了很多好看的主题，参考主题指南进行更换哦，比如我使用的hugo-theme-stack\n配置方法就是在网站目录下添加这个库\n1 git submodule add https://github.com/CaiJimmy/hugo-theme-stack themes/hugo-theme-stack 并修改config.yaml，这个可以直接复制hugo-theme-stack下examplesite的config.yaml再修改哦。最主要的就是baseurl换成你的网站地址即可！下面贴上我的配置.\nThe End\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 baseurl: https://chajiuqqq.github.io/blogs/ languageCode: en-us theme: hugo-theme-stack paginate: 5 title: 茶酒的小站 languages: en: languageName: English title: Chajiu\u0026#39;s blog weight: 1 zh-cn: languageName: 中文 title: 茶酒的小站 weight: 2 ar: languageName: عربي languagedirection: rtl title: موقع تجريبي weight: 3 # Change it to your Disqus shortname before using disqusShortname: hugo-theme-stack # GA Tracking ID googleAnalytics: # Theme i18n support # Available values: ar, bn, ca, de, el, en, es, fr, hu, id, it, ja, ko, nl, pt-br, th, uk, zh-cn, zh-hk, zh-tw DefaultContentLanguage: zh-cn # Set hasCJKLanguage to true if DefaultContentLanguage is in [zh-cn ja ko] # This will make .Summary and .WordCount behave correctly for CJK languages. hasCJKLanguage: true permalinks: post: /p/:slug/ page: /:slug/ params: mainSections: - post featuredImageField: image rssFullContent: true favicon: footer: since: 2020 customText: dateFormat: published: Jan 02, 2006 lastUpdated: Jan 02, 2006 15:04 MST sidebar: emoji: 🍥 subtitle: 一个年轻的小站 avatar: enabled: true local: true src: img/avatar.jpeg article: math: false toc: true readingTime: true license: enabled: true default: Licensed under CC BY-NC-SA 4.0 comments: enabled: true provider: disqus disqusjs: shortname: apiUrl: apiKey: admin: adminLabel: utterances: repo: issueTerm: pathname label: remark42: host: site: locale: vssue: platform: owner: repo: clientId: clientSecret: autoCreateIssue: false # Waline client configuration see: https://waline.js.org/en/reference/component.html waline: serverURL: lang: pageview: emoji: - https://unpkg.com/@waline/emojis@1.0.1/weibo requiredMeta: - name - email - url locale: admin: Admin placeholder: twikoo: envId: region: path: lang: # See https://cactus.chat/docs/reference/web-client/#configuration for description of the various options cactus: defaultHomeserverUrl: \u0026#34;https://matrix.cactus.chat:8448\u0026#34; serverName: \u0026#34;cactus.chat\u0026#34; siteName: \u0026#34;\u0026#34; # You must insert a unique identifier here matching the one you registered (See https://cactus.chat/docs/getting-started/quick-start/#register-your-site) giscus: repo: repoID: category: categoryID: mapping: lightTheme: darkTheme: reactionsEnabled: 1 emitMetadata: 0 gitalk: owner: admin: repo: clientID: clientSecret: cusdis: host: id: widgets: homepage: - type: search - type: archives params: limit: 5 - type: categories params: limit: 10 - type: tag-cloud params: limit: 10 page: - type: toc opengraph: twitter: # Your Twitter username site: # Available values: summary, summary_large_image card: summary_large_image defaultImage: opengraph: enabled: false local: false src: colorScheme: # Display toggle toggle: true # Available values: auto, light, dark default: auto imageProcessing: cover: enabled: true content: enabled: true ### Custom menu ### See https://docs.stack.jimmycai.com/configuration/custom-menu.html ### To remove about, archive and search page menu item, remove `menu` field from their FrontMatter menu: main: [] social: - identifier: github name: GitHub url: https://github.com/chajiuqqq params: icon: brand-github - identifier: twitter name: Twitter url: https://twitter.com params: icon: brand-twitter related: includeNewer: true threshold: 60 toLower: false indices: - name: tags weight: 100 - name: categories weight: 200 markup: goldmark: renderer: ## Set to true if you have HTML content inside Markdown unsafe: false tableOfContents: endLevel: 4 ordered: true startLevel: 2 highlight: noClasses: false codeFences: true guessSyntax: true lineNoStart: 1 lineNos: true lineNumbersInTable: true tabWidth: 4 ","date":"2022-08-24T16:32:10+08:00","permalink":"https://chajiuqqq.github.io/blogs/p/hugo--gitpages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/","title":"Hugo + GitPages博客搭建指南"},{"content":"正文 你好，测试\n这是2朵美丽的花：\n竖排：\n第二段 会议\n","date":"2022-08-18T15:20:49+08:00","image":"https://chajiuqqq.github.io/blogs/p/say-hello/butterfly-7353884_1920_hue396b29070a692a4e28129944f8b6538_270095_120x120_fill_q75_box_smart1.jpeg","permalink":"https://chajiuqqq.github.io/blogs/p/say-hello/","title":"Say Hello"}]